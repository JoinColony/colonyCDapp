directive @aws_api_key on FIELD_DEFINITION | OBJECT

directive @aws_iam on FIELD_DEFINITION | OBJECT

directive @aws_oidc on FIELD_DEFINITION | OBJECT

directive @aws_lambda on FIELD_DEFINITION | OBJECT

directive @aws_cognito_user_pools(cognito_groups: [String!]) on FIELD_DEFINITION | OBJECT

directive @aws_auth(cognito_groups: [String!]!) on FIELD_DEFINITION

directive @aws_subscribe(mutations: [String!]) on FIELD_DEFINITION

"""Input data for fetching a token's information from DB or chain"""
input TokenFromEverywhereArguments {
  """Address of the token on the blockchain"""
  tokenAddress: String!
}

"""Input data for fetching the list of members for a specific Colony"""
input MembersForColonyInput {
  """Address of the Colony"""
  colonyAddress: String!

  """Root hash for the reputation state"""
  rootHash: String

  """ID of the domain within the Colony"""
  domainId: Int

  """Sorting method to apply to the member list"""
  sortingMethod: SortingMethod
}

"""
Input data for creating a unique user within the Colony Network Use this instead of the automatically generated `CreateUserInput` input type
"""
input CreateUniqueUserInput {
  """Unique identifier for the user. This is the user's wallet address"""
  id: ID!

  """The username"""
  name: String!

  """Profile data for the user"""
  profile: ProfileInput
}

"""
**Deprecated** Extra permissions for a user, stored during the registration process
"""
enum EmailPermissions {
  """Permission to send notifications to the user"""
  sendNotifications

  """
  Person is registered and solved the captcha, they can use gasless transactions
  """
  isHuman
}

"""Input data for a user's profile metadata"""
input ProfileMetadataInput {
  """List of email permissions for the user"""
  emailPermissions: [String!]!

  """A flag to indicate whether the user has enabled metatransactions"""
  metatransactionsEnabled: Boolean

  """A flag to indicate whether the user has enabled the decentralized mode"""
  decentralizedModeEnabled: Boolean

  """The URL of the user's custom RPC node"""
  customRpc: String
}

"""Input data for relevant chain metadata of a Colony (if applicable)"""
input ChainMetadataInput {
  """The network the Colony is deployed on"""
  network: Network

  """The chain ID of the network"""
  chainId: Int!

  """The transaction hash of the creation transaction"""
  transactionHash: String

  """The log index of the creation transaction"""
  logIndex: Int

  """The block number of the creation transaction"""
  blockNumber: Int
}

"""
Input data for the status of a Colony's native token

Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later
"""
input NativeTokenStatusInput {
  """Whether the native token is unlocked"""
  unlocked: Boolean

  """Whether the native token is mintable"""
  mintable: Boolean

  """Whether the native token can be unlocked"""
  unlockable: Boolean
}

"""
Input data for a Colony's status information

This is set when a Colony is created and can be changed later
"""
input ColonyStatusInput {
  """Status information for the Colony's native token"""
  nativeToken: NativeTokenStatusInput

  """Whether the Colony is in recovery mode"""
  recovery: Boolean
}

"""
Input data for creating a unique Colony within the Colony Network. Use this instead of the automatically generated `CreateColonyInput` input type
"""
input CreateUniqueColonyInput {
  """
  Unique identifier for the Colony. This is the Colony's contract address
  """
  id: ID!

  """Display name of the Colony"""
  name: String!

  """Unique identifier for the Colony's native token (this is its address)"""
  colonyNativeTokenId: ID!

  """Type of the Colony (regular or MetaColony)"""
  type: ColonyType

  """Status information for the Colony"""
  status: ColonyStatusInput

  """Metadata related to the Colony's creation on the blockchain"""
  chainMetadata: ChainMetadataInput!

  """Version of the currently deployed Colony contract"""
  version: Int!
}

"""Input data to use when creating or changing a user profile"""
input ProfileInput {
  """The unique identifier for the user profile"""
  id: ID

  """The URL of the user's avatar image"""
  avatar: String

  """The URL of the user's thumbnail image"""
  thumbnail: String

  """The display name of the user"""
  displayName: String

  """A short description or biography of the user."""
  bio: String

  """The user's location (e.g., city or country)"""
  location: String

  """The user's personal or professional website"""
  website: AWSURL

  """The user's email address"""
  email: AWSEmail

  """Any additional metadata or settings related to the user profile"""
  meta: ProfileMetadataInput
}

"""
Input data for a user's reputation within a Domain in a Colony. If no `domainId` is passed, the Root Domain is used
A `rootHash` can be provided, to get reputation at a certain point in the past
"""
input GetUserReputationInput {
  """The Ethereum wallet address of the user"""
  walletAddress: String!

  """The Ethereum address of the Colony"""
  colonyAddress: String!

  """
  The ID of the Domain within the Colony. If not provided, defaults to the Root Domain
  """
  domainId: Int

  """The root hash of the reputation tree at a specific point in time"""
  rootHash: String
}

"""
Input data for updating an extension's information within a Colony, based on the Colony ID and extension hash
The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
"""
input UpdateExtensionByColonyAndHashInput {
  """The unique identifier for the Colony"""
  colonyId: ID!

  """The hash of the extension to be updated"""
  hash: String!

  """A flag to indicate whether the extension is deprecated"""
  isDeprecated: Boolean

  """A flag to indicate whether the extension is deleted"""
  isDeleted: Boolean

  """A flag to indicate whether the extension is initialized"""
  isInitialized: Boolean

  """The version of the extension"""
  version: Int

  """The Ethereum address of the user who installed the extension"""
  installedBy: String

  """The timestamp when the extension was installed"""
  installedAt: AWSTimestamp
}

"""
Input data to store the latest available version of the core Colony contract and available extensions

The extension hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network (e.g. `VotingReputation`)
"""
input SetCurrentVersionInput {
  """COLONY for the Colony contract, extension hash for extensions"""
  key: String!

  """Latest available version"""
  version: Int!
}

"""Return type for tokens gotten from DB or from chain"""
type TokenFromEverywhereReturn {
  """List of tokens found"""
  items: [Token]
}

"""
Input data for retrieving a user's reputation within the top domains of a Colony
"""
input GetReputationForTopDomainsInput {
  """The wallet address of the user"""
  walletAddress: String!

  """The address of the Colony"""
  colonyAddress: String!

  """The root hash of the reputation tree at a specific point in time"""
  rootHash: String
}

"""Input data for retrieving a user's token balance for a specific token"""
input GetUserTokenBalanceInput {
  """The wallet address of the user"""
  walletAddress: String!

  """The Colony address"""
  colonyAddress: String!

  """The address of the token"""
  tokenAddress: String!
}

"""
Input data for retrieving the state of a motion (i.e. the current period)
"""
input GetMotionStateInput {
  """The Ethereum address of the Colony"""
  colonyAddress: String!

  """The internal id of the motion in the database"""
  databaseMotionId: String!

  """The hash of the associated transaction"""
  transactionHash: String!
}

"""
Input data for retrieving the voting rewards for a user within a finished motion
"""
input GetVoterRewardsInput {
  """The Ethereum address of the user who voted"""
  voterAddress: String!

  """The Ethereum address of the Colony"""
  colonyAddress: String!

  """The on chain id of the domain in which the motion was created"""
  nativeMotionDomainId: String!

  """The on chain id of the motion"""
  motionId: String!

  """
  The root hash of the reputation tree at the time the motion was created
  """
  rootHash: String!
}

"""
Input data for retrieving the timeout of the current period the motion is in
"""
input GetMotionTimeoutPeriodsInput {
  """The on chain id of the motion"""
  motionId: String!

  """The Ethereum address of the user who voted"""
  colonyAddress: String!
}

"""A type representing a user's reputation within a domain"""
type UserDomainReputation {
  """The integer ID of the Domain within the Colony"""
  domainId: Int!

  """The user's reputation within the domain, represented as a percentage"""
  reputationPercentage: String!
}

"""A return type that contains an array of UserDomainReputation items"""
type GetReputationForTopDomainsReturn {
  """An array of UserDomainReputation items"""
  items: [UserDomainReputation!]
}

"""A return type representing the breakdown of a user's token balance"""
type GetUserTokenBalanceReturn {
  """
  The total token balance, including inactive, locked, and active balances
  """
  balance: String

  """
  The inactive portion of the user's token balance
  This is the balance of a token that is in a users wallet but can't be used by the Colony Network (e.g. for governance)
  """
  inactiveBalance: String

  """
  The locked portion of the user's token balance
  This is the balance of a token that is staked (e.g. in motions)
  """
  lockedBalance: String

  """
  The active portion of the user's token balance
  This is the balance that is approved for the Colony Network to use (e.g. for governance)
  """
  activeBalance: String

  """
  The pending portion of the user's token balance
  These are tokens that have been sent to the wallet, but are inaccessible until all locks are cleared and then these tokens are claimed
  """
  pendingBalance: String
}

"""
A return type that contains the timeout periods the motion can be in
Represented via a string-integer in milliseconds. Will report 0 for periods that are elapsed and will show the accumulated time for later periods
"""
type GetMotionTimeoutPeriodsReturn {
  """Time left in staking period"""
  timeLeftToStake: String!

  """Time left in voting period"""
  timeLeftToVote: String!

  """Time left in reveal period"""
  timeLeftToReveal: String!

  """Time left in escalation period"""
  timeLeftToEscalate: String!
}

"""
A return type representing the members of a Colony

Definitions:
* Member = User watching a Colony, with or without reputation
* Contributor = User watching a Colony WITH reputation
* Watcher = User watching a Colony WITHOUT reputation
"""
type MembersForColonyReturn {
  """User watching a Colony WITH reputation"""
  contributors: [Contributor!]

  """User watching a Colony WITHOUT reputation"""
  watchers: [Watcher!]
}

"""
A return type that contains the voting reward for a user and a motion
`min` and `max` specify the potential reward range when the actual reward is unknown (before the _reveal_ phase)
"""
type VoterRewardsReturn {
  """
  The minimum possible reward amount
  Only useful before the _reveal_ phase, when the actual amount is known
  """
  min: String!

  """
  The maximum possible reward amount
  Only useful before the _reveal_ phase, when the actual amount is known
  """
  max: String!

  """The actual reward amount"""
  reward: String!
}

"""
Variants of different token types a Colony can use
As Colonies can use multiple tokens and even own tokens (BYOT), we need to differentiate
"""
enum TokenType {
  """
  A (ERC20-compatible) token that was deployed with Colony. It has a few more features, like minting through the Colony itself
  """
  COLONY

  """An ERC20-compatible token"""
  ERC20

  """
  The native token of the Chain used (e.g. ETH on mainnet or xDAI on Gnosis-Chain)
  """
  CHAIN_NATIVE
}

"""Variants of supported Ethereum networks"""
enum Network {
  """Local development network using Ganache"""
  GANACHE

  """Ethereum Mainnet"""
  MAINNET

  """Ethereum Goerli test network"""
  GOERLI

  """Gnosis Chain network"""
  GNOSIS

  """Fork of Gnosis Chain for QA purposes"""
  GNOSISFORK
}

"""Variants of available domain colors as used in the dApp"""
enum DomainColor {
  """A light pink color"""
  LIGHT_PINK

  """A pink color"""
  PINK

  """A black color"""
  BLACK

  """An emerald green color"""
  EMERALD_GREEN

  """A blue color"""
  BLUE

  """A yellow color"""
  YELLOW

  """A red color"""
  RED

  """A green color"""
  GREEN

  """A pale indigo color"""
  PERIWINKLE

  """A gold color"""
  GOLD

  """An aqua color"""
  AQUA

  """A blue-grey(ish) color"""
  BLUE_GREY

  """A purple color"""
  PURPLE

  """An orange color"""
  ORANGE

  """A magenta color"""
  MAGENTA

  """A purple-grey(ish) color"""
  PURPLE_GREY
}

"""Variants of Colony types"""
enum ColonyType {
  """A regular Colony"""
  COLONY

  """The MetaColony, which governs the entire Colony Network"""
  METACOLONY
}

"""
Variants of Colony Network blockchain events

These can all happen in a Colony and will be interpreted by the dApp according to their types
"""
enum ColonyActionType {
  """A generic or unspecified Colony action"""
  GENERIC

  """An motion action placeholder that should not be used"""
  NULL_MOTION

  """An action unrelated to the currently viewed Colony"""
  WRONG_COLONY

  """An action related to a payment within a Colony"""
  PAYMENT

  """
  An action related to a payment that was created via a motion within a Colony
  """
  PAYMENT_MOTION

  """An action related to the recovery functionality of a Colony"""
  RECOVERY

  """An action related to moving funds between domains"""
  MOVE_FUNDS

  """An action related to moving funds between domains via a motion"""
  MOVE_FUNDS_MOTION

  """An action related to unlocking a token within a Colony"""
  UNLOCK_TOKEN

  """An action related to unlocking a token within a Colony via a motion"""
  UNLOCK_TOKEN_MOTION

  """An action related to minting tokens within a Colony"""
  MINT_TOKENS

  """An action related to minting tokens within a Colony via a motion"""
  MINT_TOKENS_MOTION

  """An action related to creating a domain within a Colony"""
  CREATE_DOMAIN

  """An action related to creating a domain within a Colony via a motion"""
  CREATE_DOMAIN_MOTION

  """An action related to upgrading a Colony's version"""
  VERSION_UPGRADE

  """An action related to upgrading a Colony's version via a motion"""
  VERSION_UPGRADE_MOTION

  """An action related to editing a Colony's details"""
  COLONY_EDIT

  """An action related to editing a Colony's details via a motion"""
  COLONY_EDIT_MOTION

  """An action related to editing a domain's details"""
  EDIT_DOMAIN

  """An action related to editing a domain's details via a motion"""
  EDIT_DOMAIN_MOTION

  """An action related to setting user roles within a Colony"""
  SET_USER_ROLES

  """An action related to setting user roles within a Colony via a motion"""
  SET_USER_ROLES_MOTION

  """
  An action related to a domain reputation penalty within a Colony (smite)
  """
  EMIT_DOMAIN_REPUTATION_PENALTY

  """
  An action related to a domain reputation penalty within a Colony (smite) via a motion
  """
  EMIT_DOMAIN_REPUTATION_PENALTY_MOTION

  """An action related to a domain reputation reward within a Colony"""
  EMIT_DOMAIN_REPUTATION_REWARD

  """
  An action related to a domain reputation reward within a Colony via a motion
  """
  EMIT_DOMAIN_REPUTATION_REWARD_MOTION

  """
  An action related to a creating a Decision within a Colony via a motion
  """
  CREATE_DECISION_MOTION

  """
  "
  An action related to the creation of safe transactions via Safe Control
  """
  MAKE_ARBITRARY_TRANSACTION
  MAKE_ARBITRARY_TRANSACTIONS_MOTION
}

"""Variants of sorting methods for a member list"""
enum SortingMethod {
  """Sort members by highest reputation"""
  BY_HIGHEST_REP

  """Sort members by lowest reputation"""
  BY_LOWEST_REP

  """Sort members by having more permissions"""
  BY_MORE_PERMISSIONS

  """Sort members by having fewer permissions"""
  BY_LESS_PERMISSIONS
}

enum ExpenditureStatus {
  DRAFT
  LOCKED
  FINALIZED
  CANCELLED
}

"""Root query type"""
type Query {
  """
  Fetch a token's information. Tries to get the data from the DB first, if that fails, resolves to get data from chain
  """
  getTokenFromEverywhere(input: TokenFromEverywhereArguments): TokenFromEverywhereReturn

  """Retrieve a user's reputation within the top domains of a Colony"""
  getReputationForTopDomains(input: GetReputationForTopDomainsInput): GetReputationForTopDomainsReturn

  """Retrieve a user's reputation within a specific domain in a Colony"""
  getUserReputation(input: GetUserReputationInput): String

  """Retrieve a user's token balance for a specific token"""
  getUserTokenBalance(input: GetUserTokenBalanceInput): GetUserTokenBalanceReturn

  """Fetch the list of members for a specific Colony"""
  getMembersForColony(input: MembersForColonyInput): MembersForColonyReturn

  """Get the state of a motion (i.e. the current period)"""
  getMotionState(input: GetMotionStateInput): Int!

  """Get the voting reward for a user and a motion"""
  getVoterRewards(input: GetVoterRewardsInput): VoterRewardsReturn

  """Get the timeout for the current period of a motion"""
  getMotionTimeoutPeriods(input: GetMotionTimeoutPeriodsInput): GetMotionTimeoutPeriodsReturn
  getProfile(id: ID!): Profile
  listProfiles(filter: ModelProfileFilterInput, limit: Int, nextToken: String): ModelProfileConnection
  getToken(id: ID!): Token
  listTokens(filter: ModelTokenFilterInput, limit: Int, nextToken: String): ModelTokenConnection
  getColony(id: ID!): Colony
  listColonies(filter: ModelColonyFilterInput, limit: Int, nextToken: String): ModelColonyConnection
  getColonyMetadata(id: ID!): ColonyMetadata
  listColonyMetadata(filter: ModelColonyMetadataFilterInput, limit: Int, nextToken: String): ModelColonyMetadataConnection
  getUser(id: ID!): User
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
  getColonyStake(id: ID!): ColonyStake
  listColonyStakes(filter: ModelColonyStakeFilterInput, limit: Int, nextToken: String): ModelColonyStakeConnection
  getDomain(id: ID!): Domain
  listDomains(filter: ModelDomainFilterInput, limit: Int, nextToken: String): ModelDomainConnection
  getDomainMetadata(id: ID!): DomainMetadata
  listDomainMetadata(filter: ModelDomainMetadataFilterInput, limit: Int, nextToken: String): ModelDomainMetadataConnection
  getColonyFundsClaim(id: ID!): ColonyFundsClaim
  listColonyFundsClaims(filter: ModelColonyFundsClaimFilterInput, limit: Int, nextToken: String): ModelColonyFundsClaimConnection
  getMotionMessage(id: ID!): MotionMessage
  listMotionMessages(filter: ModelMotionMessageFilterInput, limit: Int, nextToken: String): ModelMotionMessageConnection
  getColonyMotion(id: ID!): ColonyMotion
  listColonyMotions(filter: ModelColonyMotionFilterInput, limit: Int, nextToken: String): ModelColonyMotionConnection
  getContractEvent(id: ID!): ContractEvent
  listContractEvents(filter: ModelContractEventFilterInput, limit: Int, nextToken: String): ModelContractEventConnection
  getColonyExtension(id: ID!): ColonyExtension
  listColonyExtensions(filter: ModelColonyExtensionFilterInput, limit: Int, nextToken: String): ModelColonyExtensionConnection
  getCurrentVersion(id: ID!): CurrentVersion
  listCurrentVersions(filter: ModelCurrentVersionFilterInput, limit: Int, nextToken: String): ModelCurrentVersionConnection
  getCurrentNetworkInverseFee(id: ID!): CurrentNetworkInverseFee
  listCurrentNetworkInverseFees(filter: ModelCurrentNetworkInverseFeeFilterInput, limit: Int, nextToken: String): ModelCurrentNetworkInverseFeeConnection
  getColonyAction(id: ID!): ColonyAction
  listColonyActions(filter: ModelColonyActionFilterInput, limit: Int, nextToken: String): ModelColonyActionConnection
  getColonyDecision(id: ID!): ColonyDecision
  listColonyDecisions(filter: ModelColonyDecisionFilterInput, limit: Int, nextToken: String): ModelColonyDecisionConnection
  getColonyRole(id: ID!): ColonyRole
  listColonyRoles(filter: ModelColonyRoleFilterInput, limit: Int, nextToken: String): ModelColonyRoleConnection
  getColonyHistoricRole(id: ID!): ColonyHistoricRole
  listColonyHistoricRoles(filter: ModelColonyHistoricRoleFilterInput, limit: Int, nextToken: String): ModelColonyHistoricRoleConnection
  getIngestorStats(id: ID!): IngestorStats
  listIngestorStats(filter: ModelIngestorStatsFilterInput, limit: Int, nextToken: String): ModelIngestorStatsConnection
  getExpenditure(id: ID!): Expenditure
  listExpenditures(filter: ModelExpenditureFilterInput, limit: Int, nextToken: String): ModelExpenditureConnection
  getAnnotation(id: ID!): Annotation
  listAnnotations(filter: ModelAnnotationFilterInput, limit: Int, nextToken: String): ModelAnnotationConnection
  getSafeTransaction(id: ID!): SafeTransaction
  listSafeTransactions(filter: ModelSafeTransactionFilterInput, limit: Int, nextToken: String): ModelSafeTransactionConnection
  getColonyTokens(id: ID!): ColonyTokens
  listColonyTokens(filter: ModelColonyTokensFilterInput, limit: Int, nextToken: String): ModelColonyTokensConnection
  getUserTokens(id: ID!): UserTokens
  listUserTokens(filter: ModelUserTokensFilterInput, limit: Int, nextToken: String): ModelUserTokensConnection
  getWatchedColonies(id: ID!): WatchedColonies
  listWatchedColonies(filter: ModelWatchedColoniesFilterInput, limit: Int, nextToken: String): ModelWatchedColoniesConnection
  getProfileByEmail(email: AWSEmail!, sortDirection: ModelSortDirection, filter: ModelProfileFilterInput, limit: Int, nextToken: String): ModelProfileConnection
  getTokenByAddress(id: ID!, sortDirection: ModelSortDirection, filter: ModelTokenFilterInput, limit: Int, nextToken: String): ModelTokenConnection
  getTokensByType(type: TokenType!, sortDirection: ModelSortDirection, filter: ModelTokenFilterInput, limit: Int, nextToken: String): ModelTokenConnection
  getColonyByAddress(id: ID!, sortDirection: ModelSortDirection, filter: ModelColonyFilterInput, limit: Int, nextToken: String): ModelColonyConnection
  getColonyByName(name: String!, sortDirection: ModelSortDirection, filter: ModelColonyFilterInput, limit: Int, nextToken: String): ModelColonyConnection
  getColoniesByNativeTokenId(nativeTokenId: ID!, sortDirection: ModelSortDirection, filter: ModelColonyFilterInput, limit: Int, nextToken: String): ModelColonyConnection
  getColonyByType(type: ColonyType!, sortDirection: ModelSortDirection, filter: ModelColonyFilterInput, limit: Int, nextToken: String): ModelColonyConnection
  getUserByAddress(id: ID!, sortDirection: ModelSortDirection, filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
  getUserByName(name: String!, sortDirection: ModelSortDirection, filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
  getColonyStakeByUserAddress(userId: ID!, colonyId: ModelIDKeyConditionInput, sortDirection: ModelSortDirection, filter: ModelColonyStakeFilterInput, limit: Int, nextToken: String): ModelColonyStakeConnection
  getMotionMessageByMotionId(motionId: ID!, createdAt: ModelStringKeyConditionInput, sortDirection: ModelSortDirection, filter: ModelMotionMessageFilterInput, limit: Int, nextToken: String): ModelMotionMessageConnection
  getExtensionByColonyAndHash(colonyId: ID!, hash: ModelStringKeyConditionInput, sortDirection: ModelSortDirection, filter: ModelColonyExtensionFilterInput, limit: Int, nextToken: String): ModelColonyExtensionConnection
  getExtensionsByHash(hash: String!, sortDirection: ModelSortDirection, filter: ModelColonyExtensionFilterInput, limit: Int, nextToken: String): ModelColonyExtensionConnection
  getCurrentVersionByKey(key: String!, sortDirection: ModelSortDirection, filter: ModelCurrentVersionFilterInput, limit: Int, nextToken: String): ModelCurrentVersionConnection
  getActionsByColony(colonyId: ID!, createdAt: ModelStringKeyConditionInput, sortDirection: ModelSortDirection, filter: ModelColonyActionFilterInput, limit: Int, nextToken: String): ModelColonyActionConnection
  getColonyActionByMotionId(motionId: ID!, sortDirection: ModelSortDirection, filter: ModelColonyActionFilterInput, limit: Int, nextToken: String): ModelColonyActionConnection
  getColonyDecisionByActionId(actionId: ID!, sortDirection: ModelSortDirection, filter: ModelColonyDecisionFilterInput, limit: Int, nextToken: String): ModelColonyDecisionConnection
  getColonyDecisionByColonyAddress(colonyAddress: String!, createdAt: ModelStringKeyConditionInput, sortDirection: ModelSortDirection, filter: ModelColonyDecisionFilterInput, limit: Int, nextToken: String): ModelColonyDecisionConnection
  getColonyHistoricRoleByDate(type: String!, createdAt: ModelStringKeyConditionInput, sortDirection: ModelSortDirection, filter: ModelColonyHistoricRoleFilterInput, limit: Int, nextToken: String): ModelColonyHistoricRoleConnection
  getExpendituresByColony(colonyId: ID!, createdAt: ModelStringKeyConditionInput, sortDirection: ModelSortDirection, filter: ModelExpenditureFilterInput, limit: Int, nextToken: String): ModelExpenditureConnection
}

"""Root mutation type"""
type Mutation {
  """
  Create a unique user within the Colony Network. Use this instead of the automatically generated `createUser` mutation
  """
  createUniqueUser(input: CreateUniqueUserInput): User

  """
  Create a unique Colony within the Colony Network. Use this instead of the automatically generated `createColony` mutation
  """
  createUniqueColony(input: CreateUniqueColonyInput): Colony

  """Updates the latest available version of a Colony or an extension"""
  setCurrentVersion(input: SetCurrentVersionInput): Boolean

  """
  Update an extension's details for a specific Colony
  The extension hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network (e.g. `VotingReputation`)
  """
  updateExtensionByColonyAndHash(input: UpdateExtensionByColonyAndHashInput): ColonyExtension
  createProfile(input: CreateProfileInput!, condition: ModelProfileConditionInput): Profile
  updateProfile(input: UpdateProfileInput!, condition: ModelProfileConditionInput): Profile
  deleteProfile(input: DeleteProfileInput!, condition: ModelProfileConditionInput): Profile
  createToken(input: CreateTokenInput!, condition: ModelTokenConditionInput): Token
  updateToken(input: UpdateTokenInput!, condition: ModelTokenConditionInput): Token
  deleteToken(input: DeleteTokenInput!, condition: ModelTokenConditionInput): Token
  createColony(input: CreateColonyInput!, condition: ModelColonyConditionInput): Colony
  updateColony(input: UpdateColonyInput!, condition: ModelColonyConditionInput): Colony
  deleteColony(input: DeleteColonyInput!, condition: ModelColonyConditionInput): Colony
  createColonyMetadata(input: CreateColonyMetadataInput!, condition: ModelColonyMetadataConditionInput): ColonyMetadata
  updateColonyMetadata(input: UpdateColonyMetadataInput!, condition: ModelColonyMetadataConditionInput): ColonyMetadata
  deleteColonyMetadata(input: DeleteColonyMetadataInput!, condition: ModelColonyMetadataConditionInput): ColonyMetadata
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User
  createColonyStake(input: CreateColonyStakeInput!, condition: ModelColonyStakeConditionInput): ColonyStake
  updateColonyStake(input: UpdateColonyStakeInput!, condition: ModelColonyStakeConditionInput): ColonyStake
  deleteColonyStake(input: DeleteColonyStakeInput!, condition: ModelColonyStakeConditionInput): ColonyStake
  createDomain(input: CreateDomainInput!, condition: ModelDomainConditionInput): Domain
  updateDomain(input: UpdateDomainInput!, condition: ModelDomainConditionInput): Domain
  deleteDomain(input: DeleteDomainInput!, condition: ModelDomainConditionInput): Domain
  createDomainMetadata(input: CreateDomainMetadataInput!, condition: ModelDomainMetadataConditionInput): DomainMetadata
  updateDomainMetadata(input: UpdateDomainMetadataInput!, condition: ModelDomainMetadataConditionInput): DomainMetadata
  deleteDomainMetadata(input: DeleteDomainMetadataInput!, condition: ModelDomainMetadataConditionInput): DomainMetadata
  createColonyFundsClaim(input: CreateColonyFundsClaimInput!, condition: ModelColonyFundsClaimConditionInput): ColonyFundsClaim
  updateColonyFundsClaim(input: UpdateColonyFundsClaimInput!, condition: ModelColonyFundsClaimConditionInput): ColonyFundsClaim
  deleteColonyFundsClaim(input: DeleteColonyFundsClaimInput!, condition: ModelColonyFundsClaimConditionInput): ColonyFundsClaim
  createMotionMessage(input: CreateMotionMessageInput!, condition: ModelMotionMessageConditionInput): MotionMessage
  updateMotionMessage(input: UpdateMotionMessageInput!, condition: ModelMotionMessageConditionInput): MotionMessage
  deleteMotionMessage(input: DeleteMotionMessageInput!, condition: ModelMotionMessageConditionInput): MotionMessage
  createColonyMotion(input: CreateColonyMotionInput!, condition: ModelColonyMotionConditionInput): ColonyMotion
  updateColonyMotion(input: UpdateColonyMotionInput!, condition: ModelColonyMotionConditionInput): ColonyMotion
  deleteColonyMotion(input: DeleteColonyMotionInput!, condition: ModelColonyMotionConditionInput): ColonyMotion
  createContractEvent(input: CreateContractEventInput!, condition: ModelContractEventConditionInput): ContractEvent
  updateContractEvent(input: UpdateContractEventInput!, condition: ModelContractEventConditionInput): ContractEvent
  deleteContractEvent(input: DeleteContractEventInput!, condition: ModelContractEventConditionInput): ContractEvent
  createColonyExtension(input: CreateColonyExtensionInput!, condition: ModelColonyExtensionConditionInput): ColonyExtension
  updateColonyExtension(input: UpdateColonyExtensionInput!, condition: ModelColonyExtensionConditionInput): ColonyExtension
  deleteColonyExtension(input: DeleteColonyExtensionInput!, condition: ModelColonyExtensionConditionInput): ColonyExtension
  createCurrentVersion(input: CreateCurrentVersionInput!, condition: ModelCurrentVersionConditionInput): CurrentVersion
  updateCurrentVersion(input: UpdateCurrentVersionInput!, condition: ModelCurrentVersionConditionInput): CurrentVersion
  deleteCurrentVersion(input: DeleteCurrentVersionInput!, condition: ModelCurrentVersionConditionInput): CurrentVersion
  createCurrentNetworkInverseFee(input: CreateCurrentNetworkInverseFeeInput!, condition: ModelCurrentNetworkInverseFeeConditionInput): CurrentNetworkInverseFee
  updateCurrentNetworkInverseFee(input: UpdateCurrentNetworkInverseFeeInput!, condition: ModelCurrentNetworkInverseFeeConditionInput): CurrentNetworkInverseFee
  deleteCurrentNetworkInverseFee(input: DeleteCurrentNetworkInverseFeeInput!, condition: ModelCurrentNetworkInverseFeeConditionInput): CurrentNetworkInverseFee
  createColonyAction(input: CreateColonyActionInput!, condition: ModelColonyActionConditionInput): ColonyAction
  updateColonyAction(input: UpdateColonyActionInput!, condition: ModelColonyActionConditionInput): ColonyAction
  deleteColonyAction(input: DeleteColonyActionInput!, condition: ModelColonyActionConditionInput): ColonyAction
  createColonyDecision(input: CreateColonyDecisionInput!, condition: ModelColonyDecisionConditionInput): ColonyDecision
  updateColonyDecision(input: UpdateColonyDecisionInput!, condition: ModelColonyDecisionConditionInput): ColonyDecision
  deleteColonyDecision(input: DeleteColonyDecisionInput!, condition: ModelColonyDecisionConditionInput): ColonyDecision
  createColonyRole(input: CreateColonyRoleInput!, condition: ModelColonyRoleConditionInput): ColonyRole
  updateColonyRole(input: UpdateColonyRoleInput!, condition: ModelColonyRoleConditionInput): ColonyRole
  deleteColonyRole(input: DeleteColonyRoleInput!, condition: ModelColonyRoleConditionInput): ColonyRole
  createColonyHistoricRole(input: CreateColonyHistoricRoleInput!, condition: ModelColonyHistoricRoleConditionInput): ColonyHistoricRole
  updateColonyHistoricRole(input: UpdateColonyHistoricRoleInput!, condition: ModelColonyHistoricRoleConditionInput): ColonyHistoricRole
  deleteColonyHistoricRole(input: DeleteColonyHistoricRoleInput!, condition: ModelColonyHistoricRoleConditionInput): ColonyHistoricRole
  createIngestorStats(input: CreateIngestorStatsInput!, condition: ModelIngestorStatsConditionInput): IngestorStats
  updateIngestorStats(input: UpdateIngestorStatsInput!, condition: ModelIngestorStatsConditionInput): IngestorStats
  deleteIngestorStats(input: DeleteIngestorStatsInput!, condition: ModelIngestorStatsConditionInput): IngestorStats
  createExpenditure(input: CreateExpenditureInput!, condition: ModelExpenditureConditionInput): Expenditure
  updateExpenditure(input: UpdateExpenditureInput!, condition: ModelExpenditureConditionInput): Expenditure
  deleteExpenditure(input: DeleteExpenditureInput!, condition: ModelExpenditureConditionInput): Expenditure
  createAnnotation(input: CreateAnnotationInput!, condition: ModelAnnotationConditionInput): Annotation
  updateAnnotation(input: UpdateAnnotationInput!, condition: ModelAnnotationConditionInput): Annotation
  deleteAnnotation(input: DeleteAnnotationInput!, condition: ModelAnnotationConditionInput): Annotation
  createSafeTransaction(input: CreateSafeTransactionInput!, condition: ModelSafeTransactionConditionInput): SafeTransaction
  updateSafeTransaction(input: UpdateSafeTransactionInput!, condition: ModelSafeTransactionConditionInput): SafeTransaction
  deleteSafeTransaction(input: DeleteSafeTransactionInput!, condition: ModelSafeTransactionConditionInput): SafeTransaction
  createColonyTokens(input: CreateColonyTokensInput!, condition: ModelColonyTokensConditionInput): ColonyTokens
  updateColonyTokens(input: UpdateColonyTokensInput!, condition: ModelColonyTokensConditionInput): ColonyTokens
  deleteColonyTokens(input: DeleteColonyTokensInput!, condition: ModelColonyTokensConditionInput): ColonyTokens
  createUserTokens(input: CreateUserTokensInput!, condition: ModelUserTokensConditionInput): UserTokens
  updateUserTokens(input: UpdateUserTokensInput!, condition: ModelUserTokensConditionInput): UserTokens
  deleteUserTokens(input: DeleteUserTokensInput!, condition: ModelUserTokensConditionInput): UserTokens
  createWatchedColonies(input: CreateWatchedColoniesInput!, condition: ModelWatchedColoniesConditionInput): WatchedColonies
  updateWatchedColonies(input: UpdateWatchedColoniesInput!, condition: ModelWatchedColoniesConditionInput): WatchedColonies
  deleteWatchedColonies(input: DeleteWatchedColoniesInput!, condition: ModelWatchedColoniesConditionInput): WatchedColonies
}

"""Represents a user's profile within the Colony Network"""
type Profile {
  """Unique identifier for the user's profile"""
  id: ID!

  """URL of the user's avatar image"""
  avatar: String

  """URL of the user's thumbnail image"""
  thumbnail: String

  """Display name of the user"""
  displayName: String

  """User's bio information"""
  bio: String

  """User's location information"""
  location: String

  """URL of the user's website"""
  website: AWSURL

  """User's email address"""
  email: AWSEmail

  """Metadata associated with the user's profile"""
  meta: ProfileMetadata
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Represents the status of a Colony's native token
Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later
"""
type NativeTokenStatus {
  """Whether the native token is unlocked"""
  unlocked: Boolean

  """Whether the user has permissions to mint new tokens"""
  mintable: Boolean

  """Whether the native token can be unlocked"""
  unlockable: Boolean
}

"""
Represents the status of a Colony

This contains important meta information about the Colony's token and other fundamental settings
"""
type ColonyStatus {
  """Status information for the Colony's native token"""
  nativeToken: NativeTokenStatus

  """Whether the Colony is in recovery mode"""
  recovery: Boolean
}

"""
Represents metadata related to a blockchain event
Applies to Colonies, Tokens and Events, but not all fields are revlant to all
It does not apply to user accounts as they can live on all networks
"""
type ChainMetadata {
  """The network the event occurred on"""
  network: Network

  """The chain ID of the event"""
  chainId: Int!

  """The transaction hash of the event"""
  transactionHash: String

  """The log index of the event"""
  logIndex: Int

  """The block number of the event"""
  blockNumber: Int
}

"""
Represents metadata for a user's profile. Mostly user specific settings
"""
type ProfileMetadata {
  """List of email permissions for the user"""
  emailPermissions: [String!]!

  """A flag to indicate whether the user has enabled metatransactions"""
  metatransactionsEnabled: Boolean

  """A flag to indicate whether the user has enabled the decentralized mode"""
  decentralizedModeEnabled: Boolean

  """The URL of the user's custom RPC node"""
  customRpc: String
}

"""
Represents a contributor within the Colony Network

A contributor is a Colony member who has reputation
"""
type Contributor {
  """Wallet address of the contributor"""
  address: String!

  """User data associated with the contributor"""
  user: User

  """
  Reputation percentage of the contributor (of all reputation within the Colony)
  """
  reputationPercentage: String

  """Reputation amount of the contributor (as an absolute number)"""
  reputationAmount: String
}

"""
Represents a watcher within the Colony Network

A watcher is a Colony member who doesn't have reputation
"""
type Watcher {
  """Wallet address of the watcher"""
  address: String!

  """User data associated with the watcher"""
  user: User
}

"""
Represents an ERC20-compatible token that is used by Colonies and users
"""
type Token {
  """Unique identifier for the token (contract address)"""
  id: ID!

  """Name of the token"""
  name: String!

  """Symbol of the token"""
  symbol: String!

  """Decimal precision of the token"""
  decimals: Int!

  """Type of the token. See `TokenType` for more information"""
  type: TokenType
  colonies(filter: ModelColonyTokensFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyTokensConnection
  users(filter: ModelUserTokensFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelUserTokensConnection

  """URL of the token's avatar image (logo)"""
  avatar: String

  """URL of the token's thumbnail image (Small logo)"""
  thumbnail: String

  """Metadata related to the chain of the token"""
  chainMetadata: ChainMetadata!

  """Timestamp of the token model's creation in the database"""
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Represents a Colony within the Colony Network"""
type Colony {
  """Unique identifier for the Colony (contract address)"""
  id: ID!

  """(Short) name of the Colony"""
  name: String!

  """The unique address of the native token of the Colony"""
  nativeTokenId: ID!

  """The native token of the Colony"""
  nativeToken: Token!
  tokens(filter: ModelColonyTokensFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyTokensConnection

  """Status information for the Colony"""
  status: ColonyStatus
  domains(filter: ModelDomainFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelDomainConnection
  watchers(filter: ModelWatchedColoniesFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelWatchedColoniesConnection
  fundsClaims(filter: ModelColonyFundsClaimFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyFundsClaimConnection

  """
  List of native chain token claims (e.g., Token 0x0000...0000: ETH, xDAI, etc.)
  """
  chainFundsClaim: ColonyChainFundsClaim

  """Type of the Colony (Regular or Metacolony)"""
  type: ColonyType

  """
  Returns a list token balances for each domain and each token that the colony has
  """
  balances: ColonyBalances

  """Metadata related to the chain of the Colony"""
  chainMetadata: ChainMetadata!
  extensions(hash: ModelStringKeyConditionInput, filter: ModelColonyExtensionFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyExtensionConnection

  """Version of the Colony"""
  version: Int!
  actions(filter: ModelColonyActionFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyActionConnection

  """List of motions within the Colony that have unclaimed stakes"""
  motionsWithUnclaimedStakes: [ColonyUnclaimedStake!]

  """Metadata of the Colony"""
  metadata: ColonyMetadata
  roles(filter: ModelColonyRoleFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyRoleConnection
  expenditures(filter: ModelExpenditureFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelExpenditureConnection
  expendituresGlobalClaimDelay: Int
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Unclaimed staking rewards for a motion"""
type ColonyUnclaimedStake {
  """The on chain id of the motion"""
  motionId: String!

  """List of unclaimed staking rewards for that motion"""
  unclaimedRewards: [StakerRewards!]!
}

"""
Colony token modifications that are stored temporarily and commited to the database once the corresponding motion passes
"""
type PendingModifiedTokenAddresses {
  """List of tokens that were added to the Colony's token list"""
  added: [String!]

  """List of tokens that were removed from the Colony's token list"""
  removed: [String!]
}

"""Represents metadata for a Colony"""
type ColonyMetadata {
  """Unique identifier for the Colony (contract address)"""
  id: ID!

  """Display name of the Colony"""
  displayName: String!

  """URL of the Colony's avatar image"""
  avatar: String

  """URL of the Colony's thumbnail image"""
  thumbnail: String

  """List of Colony metadata changelog entries"""
  changelog: [ColonyMetadataChangelog!]

  """The address book feature (aka Whitelist is active for this Colony)"""
  isWhitelistActivated: Boolean

  """List of addresses that are in the address book"""
  whitelistedAddresses: [String!]

  """
  Token addresses that were modified in a previous action (motion)
  Only present on pendingColonyMetadata for consumption in block ingestor
  """
  modifiedTokenAddresses: PendingModifiedTokenAddresses

  """List of safes that are used within the Colony"""
  safes: [Safe!]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Represents a changelog entry for Colony metadata
This is used to traverse through the history of metadata values and consolidate them into a final state
"""
type ColonyMetadataChangelog {
  """Transaction hash associated with the changelog entry"""
  transactionHash: String!

  """Display name of the Colony before the change"""
  oldDisplayName: String!

  """Display name of the Colony after the change"""
  newDisplayName: String!

  """Indicates whether the avatar has changed"""
  hasAvatarChanged: Boolean!

  """Whether entries in the address book (whitelist) have changed"""
  hasWhitelistChanged: Boolean!

  """Whether tokens have been added or removed from the Colony's token list"""
  haveTokensChanged: Boolean!

  """
  "
  Whether safes have been added or removed from the Colony's safe list
  """
  newSafes: [Safe!]
  oldSafes: [Safe!]
}

"""Represents a User within the Colony Network"""
type User {
  """Unique identifier for the user (wallet address)"""
  id: ID!

  """(Short) name of the user"""
  name: String!
  tokens(filter: ModelUserTokensFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelUserTokensConnection

  """Profile ID associated with the user"""
  profileId: ID

  """Profile information of the user"""
  profile: Profile
  watchlist(filter: ModelWatchedColoniesFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelWatchedColoniesConnection
  stakes(colonyId: ModelIDKeyConditionInput, filter: ModelColonyStakeFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyStakeConnection
  roles(filter: ModelColonyRoleFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelColonyRoleConnection
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Keeps track of the current amount a user has staked in a colony
When a user stakes, totalAmount increases. When a user reclaims their stake, totalAmount decreases.
"""
type ColonyStake {
  """
  Unique identifier for the stake
  Format: `<userId>_<colonyId>`
  """
  id: ID!

  """Unique identifier for the user"""
  userId: ID!

  """Unique identifier for the Colony"""
  colonyId: ID!

  """Total staked amount"""
  totalAmount: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Represents a Domain within the Colony Network"""
type Domain {
  """
  Unique identifier for the Domain
  This should be in the following format: `colonyAddress_nativeId`
  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  id: ID!

  """Colony ID associated with the Domain"""
  colonyId: ID!

  """Colony associated with the Domain"""
  colony: Colony!

  """
  Native ID of the Domain
  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  nativeId: Int!

  """
  Native funding pot ID of the Domain
  The native funding pot ID is assigned to a domain from the contract on creation
  """
  nativeFundingPotId: Int!

  """
  Native skill ID of the Domain
  The native skill ID is assigned to a domain from the contract on creation
  """
  nativeSkillId: Int!

  """Indicates whether the Domain is the root domain (ID 1)"""
  isRoot: Boolean!

  """Metadata of the Domain"""
  metadata: DomainMetadata
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Represents metadata for a Domain"""
type DomainMetadata {
  """
  Unique identifier for the Domain metadata
  This field is referenced by Domain id, so has to be in the same format: colonyAddress_nativeId
  """
  id: ID!

  """Name of the Domain"""
  name: String!

  """Description of the Domain"""
  description: String!

  """Color associated with the Domain"""
  color: DomainColor!

  """List of Domain metadata changelog entries"""
  changelog: [DomainMetadataChangelog!]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Represents a changelog entry for Domain metadata"""
type DomainMetadataChangelog {
  """Transaction hash associated with the changelog entry"""
  transactionHash: String!

  """Name of the Domain before the change"""
  oldName: String!

  """Name of the Domain after the change"""
  newName: String!

  """Color of the Domain before the change"""
  oldColor: DomainColor!

  """Color of the Domain after the change"""
  newColor: DomainColor!

  """Description of the Domain before the change"""
  oldDescription: String!

  """Description of the Domain after the change"""
  newDescription: String!
}

"""
Represents a Colony Funds Claim for all ERC20 tokens (except native chain tokens)
"""
type ColonyFundsClaim {
  """Unique identifier for the Colony Funds Claim"""
  id: ID!

  """Token associated with the Colony Funds Claim"""
  token: Token!

  """Block number when the Funds Claim was created"""
  createdAtBlock: Int!

  """Timestamp when the Funds Claim was created"""
  createdAt: AWSDateTime!

  """Amount claimed in the Colony Funds Claim"""
  amount: String!
  updatedAt: AWSDateTime!
  colonyFundsClaimsId: ID
  colonyFundsClaimTokenId: ID!
}

"""
Represents a native Colony Chain Funds Claim
E.g., Token 0x0000...0000: ETH, xDAI, etc
"""
type ColonyChainFundsClaim {
  """Unique identifier for the Colony Chain Funds Claim"""
  id: ID!

  """Block number when the Chain Funds Claim was created"""
  createdAtBlock: Int!

  """Timestamp when the Chain Funds Claim was created"""
  createdAt: AWSDateTime!

  """Timestamp when the Chain Funds Claim was last updated"""
  updatedAt: AWSDateTime!

  """Amount claimed in the Colony Chain Funds Claim"""
  amount: String!
}

"""Represents a Colony balance for a specific domain and token"""
type ColonyBalance {
  """Unique identifier for the Colony Balance"""
  id: ID!

  """Balance of the specific token in the domain"""
  balance: String!

  """Domain associated with the Colony Balance"""
  domain: Domain

  """
  Token associated with the Colony Balance
  Note that for the chain native token, name and symbol are empty
  """
  token: Token!
}

"""Represents a collection of Colony balances"""
type ColonyBalances {
  """List of Colony balances"""
  items: [ColonyBalance]
}

"""Input type for specifying a Domain"""
input DomainInput {
  """Unique identifier for the Domain"""
  id: ID!
}

"""Input type for specifying a Token"""
input TokenInput {
  """Unique identifier for the Token"""
  id: ID!
}

"""Input type for modifying the staked side of a motion"""
input MotionStakeValuesInput {
  """Number of votes for this motion"""
  yay: String!

  """Number of votes against this motion"""
  nay: String!
}

"""Staked sides of a motion"""
type MotionStakeValues {
  """Number of votes for this motion"""
  yay: String!

  """Number of votes against this motion"""
  nay: String!
}

"""Input used to modify the staked sides of a motion"""
input MotionStakesInput {
  """Absolute values denominated in the native token"""
  raw: MotionStakeValuesInput!

  """Values in percentage of the total stakes"""
  percentage: MotionStakeValuesInput!
}

"""Staked sides of a motion"""
type MotionStakes {
  """Absolute values denominated in the native token"""
  raw: MotionStakeValues!

  """Values in percentage of the total stakes"""
  percentage: MotionStakeValues!
}

"""Input used to modify the stakes of a user for a motion"""
input UserStakesInput {
  """The user's wallet address"""
  address: String!

  """Stake values"""
  stakes: MotionStakesInput!
}

"""Stakes that a user has made for a motion"""
type UserStakes {
  """The user's wallet address"""
  address: String!

  """Stake values"""
  stakes: MotionStakes!
}

"""Input used to modify the staker rewards of a user for a motion"""
input StakerRewardsInput {
  """The user's wallet address"""
  address: String!

  """Rewards associated with the staked sides of a motion"""
  rewards: MotionStakeValuesInput!

  """Whether the voter reward is already claimed or not"""
  isClaimed: Boolean!
}

"""Staker rewards of a user for a motion"""
type StakerRewards {
  """The user's wallet address"""
  address: String!

  """Rewards associated with the staked sides of a motion"""
  rewards: MotionStakeValues!

  """Whether the voter reward is already claimed or not"""
  isClaimed: Boolean!
}

"""Input used to modify a voter record of a user for a motion"""
input VoterRecordInput {
  """The user's wallet address"""
  address: String!

  """The voting weight denominated by the user's reputation"""
  voteCount: String!

  """
  The actual vote (yay or nay)
  nullable since we don't know the vote until it's revealed
  """
  vote: Int
}

"""A voter record of a user for a motion"""
type VoterRecord {
  """The user's wallet address"""
  address: String!

  """The voting weight denominated by the user's reputation"""
  voteCount: String!

  """
  The actual vote (yay or nay)
  nullable since we don't know the vote until it's revealed
  """
  vote: Int
}

"""Input used to create a motion status update message"""
input MotionMessageInput {
  """
  Wallet address of the initiator of the status update
  The zero address is used for messages that don't have an initiator (system messages)
  """
  initiatorAddress: String!

  """
  Internal name of the status update event (e.g. `MotionCreated`, `MotionStaked`, etc.)
  """
  name: String!

  """Unique id for the message"""
  messageKey: String!

  """Cast vote attached to the status update (if applicable)"""
  vote: String

  """Token amount relevant to the status update (if applicable)"""
  amount: String
}

"""
A status update message for a motion (will appear in the motion's timeline)
"""
type MotionMessage {
  """
  Wallet address of the initiator of the status update
  The zero address is used for messages that don't have an initiator (system messages)
  """
  initiatorAddress: ID!

  """
  Internal name of the status update event (e.g. `MotionCreated`, `MotionStaked`, etc.)
  """
  name: String!

  """Unique id for the message"""
  messageKey: String!

  """The internal database id of the motion"""
  motionId: ID!

  """Extended user object for given initiatorAddress"""
  initiatorUser: User

  """Cast vote attached to the status update (if applicable)"""
  vote: String

  """Token amount relevant to the status update (if applicable)"""
  amount: String

  """Timestamp of when the status update was created in the database"""
  createdAt: AWSDateTime!
  id: ID!
  updatedAt: AWSDateTime!
}

"""Input used to change the current state of a motion"""
input MotionStateHistoryInput {
  """Voting period is elapsed"""
  hasVoted: Boolean!

  """Whether the motion has passed"""
  hasPassed: Boolean!

  """Whether the motion has failed"""
  hasFailed: Boolean!

  """
  Whether the motion has failed and cannot be finalized (e.g. if it doesn't get staked)
  """
  hasFailedNotFinalizable: Boolean!

  """Motion is in reveal phase (votes are being revealed)"""
  inRevealPhase: Boolean!
}

"""
Quick access flages to check the current state of a motion in its lifecycle
"""
type MotionStateHistory {
  """Voting period is elapsed"""
  hasVoted: Boolean!

  """Whether the motion has passed"""
  hasPassed: Boolean!

  """Whether the motion has failed"""
  hasFailed: Boolean!

  """
  Whether the motion has failed and cannot be finalized (e.g. if it doesn't get staked)
  """
  hasFailedNotFinalizable: Boolean!

  """Motion is in reveal phase (votes are being revealed)"""
  inRevealPhase: Boolean!
}

"""Represents a Motion within a Colony"""
type ColonyMotion {
  """
  The internal database id of the motion
  To ensure uniqueness, we format as: `chainId-votingRepExtnAddress_nativeMotionId`
  """
  id: ID!

  """The on chain id of the motion"""
  nativeMotionId: String!

  """List of stakes that users have made for a motion"""
  usersStakes: [UserStakes!]!

  """List of staker rewards users will be receiving for a motion"""
  stakerRewards: [StakerRewards!]!

  """Staked sides of a motion"""
  motionStakes: MotionStakes!

  """
  Stakes remaining to activate either side of the motion
  It's a tuple: `[nayRemaining, yayRemaining]`
  """
  remainingStakes: [String!]!

  """The minimum stake that a user has to provide for it to be accepted"""
  userMinStake: String!

  """The total required stake for one side to be activated"""
  requiredStake: String!

  """Unique identifier of the motions domain in the database"""
  motionDomainId: ID!

  """Expanded domain in which the motion was created"""
  motionDomain: Domain!

  """
  The reputation root hash at the time of the creation of the motion
  Used for calculating a user's max stake in client
  """
  rootHash: String!

  """The on chain id of the domain associated with the motion"""
  nativeMotionDomainId: String!

  """Whether the motion was finalized or not"""
  isFinalized: Boolean!

  """
  Address of the VotingReputation extension
  Useful to check if we're viewing a "read-only" motion
  """
  createdBy: String!

  """A list of all of the votes cast within in the motion"""
  voterRecord: [VoterRecord!]!

  """Total voting outcome for the motion (accumulated votes)"""
  revealedVotes: MotionStakes!

  """The amount of reputation that has submitted a vote"""
  repSubmitted: String!

  """
  The total amount of reputation (among all users) that can vote for this motion
  """
  skillRep: String!

  """
  Simple flag indicating whether both sides of staking have been activated
  """
  hasObjection: Boolean!

  """
  Quick access flages to check the current state of a motion in its lifecycle
  """
  motionStateHistory: MotionStateHistory!
  messages(createdAt: ModelStringKeyConditionInput, filter: ModelMotionMessageFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelMotionMessageConnection

  """Id of the associated objection annotation, if any"""
  objectionAnnotationId: ID

  """
  The annotation object associated with the objection to the motion, if any
  """
  objectionAnnotation: Annotation

  """Whether the motion is a Simple Decision"""
  isDecision: Boolean!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
Represents an event triggered by a smart contract within the Colony Network
"""
type ContractEvent {
  """
  Unique identifier for the Contract Event, in the format chainID_transactionHash_logIndex
  """
  id: ID!

  """Name of the event"""
  name: String!

  """The unique signature of the event"""
  signature: String!

  """Metadata associated with the event's chain"""
  chainMetadata: ChainMetadata!

  """Optional association with a Colony"""
  colony: Colony

  """Optional association with a Token"""
  token: Token

  """Optional association with a Domain"""
  domain: Domain

  """Optional association with a User"""
  user: User

  """Address of the agent who initiated the event"""
  agent: String!

  """Address of the target contract on the receiving end of the event"""
  target: String!

  """Optional encoded arguments as a JSON string"""
  encodedArguments: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  contractEventColonyId: ID
  contractEventTokenId: ID
  contractEventDomainId: ID
  contractEventUserId: ID
}

"""
Parameters that were set when installing the VotingReputation extension
For more info see [here](https://docs.colony.io/colonysdk/api/classes/VotingReputation#extension-parameters)
"""
type VotingReputationParams {
  """
  Percentage of the team's reputation that needs to be staked ot activate either side of the motion
  """
  totalStakeFraction: String!

  """Percentage of the losing side's stake that is awarded to the voters"""
  voterRewardFraction: String!

  """Minimum percentage of the total stake that each user has to provide"""
  userMinStakeFraction: String!

  """
  Percentage of the total reputation that voted should end the voting period
  """
  maxVoteFraction: String!

  """Time that the staking period will last (in seconds)"""
  stakePeriod: String!

  """Time that the voting period will last (in seconds)"""
  submitPeriod: String!

  """Time that the reveal period will last (in seconds)"""
  revealPeriod: String!

  """Time that the escalation period will last (in seconds)"""
  escalationPeriod: String!
}

"""Map of parameters that extensions are initialised with"""
type ExtensionParams {
  """Initialization parameters for the `VotingReputation` extension"""
  votingReputation: VotingReputationParams
}

"""Represents a single extension installed on a Colony"""
type ColonyExtension {
  """Unique identifier for the ColonyExtension"""
  id: ID!

  """
  The identifier of the Colony that the extension belongs to (the Colony's address)
  """
  colonyId: ID!

  """The Colony that the extension belongs to"""
  colony: Colony!

  """
  The unique hash of the extension
  The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
  """
  hash: String!

  """The address of the user who installed the extension"""
  installedBy: String!

  """The timestamp when the extension was installed"""
  installedAt: AWSTimestamp!

  """Indicates whether the extension is deprecated"""
  isDeprecated: Boolean!

  """Indicates whether the extension has been removed"""
  isDeleted: Boolean!

  """Indicates whether the extension has been initialized"""
  isInitialized: Boolean!

  """The version number of the extension"""
  version: Int!

  """Map of parameters that extension was initialised with"""
  params: ExtensionParams
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Represents the current version of an entity in the system"""
type CurrentVersion {
  """Unique identifier for the CurrentVersion"""
  id: ID!

  """The key used to look up the current version"""
  key: String!

  """The current version number"""
  version: Int!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""
The current inverse of the network fee (in wei)
(divide 1 by it and get the actual network fee)
"""
type CurrentNetworkInverseFee {
  """Unique identifier for the network fee"""
  id: ID!

  """The inverse fee"""
  inverseFee: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Represents an action performed within a Colony"""
type ColonyAction {
  """Unique identifier for the ColonyAction"""
  id: ID!

  """The identifier of the Colony that the action belongs to"""
  colonyId: ID!

  """The Colony that the action belongs to"""
  colony: Colony!

  """The type of action performed"""
  type: ColonyActionType!

  """The block number where the action was recorded"""
  blockNumber: Int!

  """Will be true if the action is a motion"""
  isMotion: Boolean

  """The internal database id of the motion"""
  motionId: ID

  """Expanded `ColonyMotion` for the corresponding `motionId`"""
  motionData: ColonyMotion

  """
  Whether to show the motion in the actions list
  True for (forced) actions. True for motions if staked above 10%
  """
  showInActionsList: Boolean!

  """The timestamp when the action was created"""
  createdAt: AWSDateTime!

  """
  The Ethereum address of the action initiator. Can be a user, extension or colony
  """
  initiatorAddress: ID!

  """The User who initiated the action, if applicable"""
  initiatorUser: User

  """The ColonyExtension that initiated the action, if applicable"""
  initiatorExtension: ColonyExtension

  """The Colony that initiated the action, if applicable"""
  initiatorColony: Colony

  """The Token contract that initiated the action, if applicable"""
  initiatorToken: Token

  """The address of the action recipient, if applicable"""
  recipientAddress: ID

  """The User who received the action, if applicable"""
  recipientUser: User

  """The corresponding Colony which was involved the action, if applicable"""
  recipientColony: Colony

  """
  The corresponding extension which was involved the action, if applicable
  """
  recipientExtension: ColonyExtension

  """The address of the token that was received the action, if applicable"""
  recipientToken: Token

  """The amount involved in the action, if applicable"""
  amount: String

  """
  The Ethereum address of the token involved in the action, if applicable
  """
  tokenAddress: ID

  """The Token involved in the action, if applicable"""
  token: Token

  """The source Domain identifier, if applicable"""
  fromDomainId: ID

  """The source Domain of the action, if applicable"""
  fromDomain: Domain

  """The target Domain identifier, if applicable"""
  toDomainId: ID

  """The target Domain of the action, if applicable"""
  toDomain: Domain

  """The fundamental chain id"""
  fundamentalChainId: Int

  """The resulting new Colony version, if applicable"""
  newColonyVersion: Int

  """
  Identifier of domain metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingDomainMetadataId: ID

  """
  Domain metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingDomainMetadata: DomainMetadata

  """
  Identifier of Colony metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingColonyMetadataId: ID

  """
  Colony metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingColonyMetadata: ColonyMetadata

  """The id of the associated annotation, if there is one"""
  annotationId: ID

  """The annotation associated with the action, if there is one"""
  annotation: Annotation

  """Corresponding domainId of the motion"""
  motionDomainId: Int

  """
  If the action is a Simple Decision, it will have an id that corresponds to a ColonyDecision entry in the database.
  """
  colonyDecisionId: ID

  """Corresponding Decision data, if action is a Simple Decision"""
  decisionData: ColonyDecision

  """Colony roles that are associated with the action"""
  roles: ColonyActionRoles

  """JSON string to pass custom, dynamic event data"""
  individualEvents: String

  """Safe transactions associated with the action"""
  safeTransaction: SafeTransaction
  updatedAt: AWSDateTime!
  colonyActionsId: ID
}

type ColonyDecision {
  id: ID!
  actionId: ID!
  action: ColonyAction
  title: String!
  colonyAddress: String!
  createdAt: AWSDateTime!
  description: String!
  motionDomainId: Int!
  walletAddress: String!
  showInDecisionsList: Boolean!
  updatedAt: AWSDateTime!
}

"""Colony Roles that can be involved in an action"""
type ColonyActionRoles {
  """Recovery role"""
  role_0: Boolean

  """Root role"""
  role_1: Boolean

  """Arbitration role"""
  role_2: Boolean

  """Architecture role"""
  role_3: Boolean

  """Funding role"""
  role_5: Boolean

  """Administration role"""
  role_6: Boolean
}

"""
A snapshot of the current set of permissions a given address has in a given domain within a Colony
"""
type ColonyRole {
  """
  Unique identifier for the role snapshot
  Format: `<colonyAddress>_<domainNativeId>_<userAddress>_roles`
  """
  id: ID!

  """Unique identifier of the domain"""
  domainId: ID!

  """Expaneded `Domain` model, based on the `domainId` given"""
  domain: Domain!

  """Address of the agent the permission was set for"""
  targetAddress: ID

  """Will expand to a `User` model if permission was set for a user"""
  targetUser: User

  """
  Will expand to a `Colony` model if permission was set for another Colony
  """
  targetColony: Colony

  """
  Will expand to a `ColonyExtension` model if permission was set for a Colony extension
  """
  targetExtension: ColonyExtension

  """
  Will expand to a `Token` model if permission was set for a Token contract
  """
  targetToken: Token

  """Block at which permissions were update last"""
  latestBlock: Int!

  """Recovery role"""
  role_0: Boolean

  """Root role"""
  role_1: Boolean

  """Arbitration role"""
  role_2: Boolean

  """Architecture role"""
  role_3: Boolean

  """Funding role"""
  role_5: Boolean

  """Administration role"""
  role_6: Boolean
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  colonyRolesId: ID
}

"""Snapshot of the user's full roles/permissions at a specific block"""
type ColonyHistoricRole {
  """
  Unique identifier for the role snapshot
  Format: `colonyAddress_domainNativeId_userAddress_blockNumber_roles`
  """
  id: ID!

  """Used for amplify sorting. Set to `SortedHistoricRole`"""
  type: String!

  """Unique identifier of the domain"""
  domainId: ID!

  """Expanded `Domain` model, based on the `domainId` given"""
  domain: Domain!

  """Unique identifier of the Colony"""
  colonyId: ID!

  """Expanded `Colony` model, based on the `colonyId` given"""
  colony: Colony!

  """Address of the agent the permission was set for"""
  targetAddress: ID

  """Will expand to a `User` model if permission was set for a user"""
  targetUser: User

  """
  Will expand to a `Colony` model if permission was set for another Colony
  """
  targetColony: Colony

  """
  Will expand to a `ColonyExtension` model if permission was set for a Colony extension
  """
  targetExtension: ColonyExtension

  """
  Will expand to a `Token` model if permission was set for a Token contract
  """
  targetToken: Token

  """Block at which the snapshot was taken"""
  blockNumber: Int!

  """Recovery role"""
  role_0: Boolean

  """Root role"""
  role_1: Boolean

  """Arbitration role"""
  role_2: Boolean

  """Architecture role"""
  role_3: Boolean

  """Funding role"""
  role_5: Boolean

  """Administration role"""
  role_6: Boolean

  """Timestamp at which the database entry was created"""
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

"""Model storing block ingestor stats, as key-value entries"""
type IngestorStats {
  """Unique identifier of the ingestore stats"""
  id: ID!

  """JSON string to pass custom, dynamic values"""
  value: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Expenditure {
  id: ID!
  createdAt: AWSDateTime!
  colonyId: ID!
  colony: Colony!
  ownerAddress: ID!
  status: ExpenditureStatus!
  slots: [ExpenditureSlot!]!
  updatedAt: AWSDateTime!
  colonyExpendituresId: ID
}

type ExpenditureSlot {
  id: Int!
  recipientAddress: String
  claimDelay: Int
  payoutModifier: Int
  payouts: [ExpenditurePayout!]
}

type ExpenditurePayout {
  tokenAddress: ID!
  amount: String!
}

"""Defines an annotation for actions, motions and decisions"""
type Annotation {
  """The id of the annotation."""
  id: ID!

  """The id of the action it annotates"""
  actionId: ID!

  """The actual annotation message"""
  message: String!

  """The IPFS hash, if the annotation was also uploaded to IPFS"""
  ipfsHash: String
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type SimpleTargetProfile {
  avatarHash: String
  displayName: String
  username: String
}

type SimpleTarget {
  id: String!
  profile: SimpleTargetProfile!
  walletAddress: String!
}

type NFT {
  id: String!
  profile: NFTProfile!
  walletAddress: String!
}

type NFTProfile {
  displayName: String!
}

type SafeBalanceToken {
  name: String!
  decimals: Int!
  symbol: String!
  address: String!
  logoUri: String
}

type FunctionParam {
  name: String!
  type: String!
  value: String!
}

type NFTData {
  address: String!
  description: String
  id: String!
  imageUri: String
  logoUri: String!
  name: String
  tokenName: String!
  tokenSymbol: String!
  uri: String!
}

type SafeTransactionData {
  transactionType: String!
  token: SafeBalanceToken
  amount: String
  rawAmount: String
  recipient: SimpleTarget
  data: String
  contract: SimpleTarget
  abi: String
  contractFunction: String
  nft: NFT
  nftData: NFTData
  functionParams: [FunctionParam]
}

type SafeTransaction {
  id: ID!
  title: String!
  safe: Safe!
  transactions: [SafeTransactionData!]!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type Safe {
  name: String!
  address: String!
  chainId: Int!
  moduleContractAddress: String!
}

type ColonyTokens {
  id: ID!
  tokenID: ID!
  colonyID: ID!
  token: Token!
  colony: Colony!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type UserTokens {
  id: ID!
  tokenID: ID!
  userID: ID!
  token: Token!
  user: User!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

type WatchedColonies {
  id: ID!
  colonyID: ID!
  userID: ID!
  colony: Colony!
  user: User!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelSubscriptionStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  in: [String]
  notIn: [String]
}

input ModelSubscriptionIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  in: [Int]
  notIn: [Int]
}

input ModelSubscriptionFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  in: [Float]
  notIn: [Float]
}

input ModelSubscriptionBooleanInput {
  ne: Boolean
  eq: Boolean
}

input ModelSubscriptionIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  in: [ID]
  notIn: [ID]
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelProfileConnection {
  items: [Profile]!
  nextToken: String
}

input ModelProfileFilterInput {
  id: ModelIDInput
  avatar: ModelStringInput
  thumbnail: ModelStringInput
  displayName: ModelStringInput
  bio: ModelStringInput
  location: ModelStringInput
  website: ModelStringInput
  email: ModelStringInput
  and: [ModelProfileFilterInput]
  or: [ModelProfileFilterInput]
  not: ModelProfileFilterInput
}

input ModelProfileConditionInput {
  avatar: ModelStringInput
  thumbnail: ModelStringInput
  displayName: ModelStringInput
  bio: ModelStringInput
  location: ModelStringInput
  website: ModelStringInput
  email: ModelStringInput
  and: [ModelProfileConditionInput]
  or: [ModelProfileConditionInput]
  not: ModelProfileConditionInput
}

input CreateProfileInput {
  id: ID
  avatar: String
  thumbnail: String
  displayName: String
  bio: String
  location: String
  website: AWSURL
  email: AWSEmail
  meta: ProfileMetadataInput
}

input UpdateProfileInput {
  id: ID!
  avatar: String
  thumbnail: String
  displayName: String
  bio: String
  location: String
  website: AWSURL
  email: AWSEmail
  meta: ProfileMetadataInput
}

input DeleteProfileInput {
  id: ID!
}

input ModelSubscriptionProfileFilterInput {
  id: ModelSubscriptionIDInput
  avatar: ModelSubscriptionStringInput
  thumbnail: ModelSubscriptionStringInput
  displayName: ModelSubscriptionStringInput
  bio: ModelSubscriptionStringInput
  location: ModelSubscriptionStringInput
  website: ModelSubscriptionStringInput
  email: ModelSubscriptionStringInput
  and: [ModelSubscriptionProfileFilterInput]
  or: [ModelSubscriptionProfileFilterInput]
}

type Subscription {
  onCreateProfile(filter: ModelSubscriptionProfileFilterInput): Profile
  onUpdateProfile(filter: ModelSubscriptionProfileFilterInput): Profile
  onDeleteProfile(filter: ModelSubscriptionProfileFilterInput): Profile
  onCreateToken(filter: ModelSubscriptionTokenFilterInput): Token
  onUpdateToken(filter: ModelSubscriptionTokenFilterInput): Token
  onDeleteToken(filter: ModelSubscriptionTokenFilterInput): Token
  onCreateColony(filter: ModelSubscriptionColonyFilterInput): Colony
  onUpdateColony(filter: ModelSubscriptionColonyFilterInput): Colony
  onDeleteColony(filter: ModelSubscriptionColonyFilterInput): Colony
  onCreateColonyMetadata(filter: ModelSubscriptionColonyMetadataFilterInput): ColonyMetadata
  onUpdateColonyMetadata(filter: ModelSubscriptionColonyMetadataFilterInput): ColonyMetadata
  onDeleteColonyMetadata(filter: ModelSubscriptionColonyMetadataFilterInput): ColonyMetadata
  onCreateUser(filter: ModelSubscriptionUserFilterInput): User
  onUpdateUser(filter: ModelSubscriptionUserFilterInput): User
  onDeleteUser(filter: ModelSubscriptionUserFilterInput): User
  onCreateColonyStake(filter: ModelSubscriptionColonyStakeFilterInput): ColonyStake
  onUpdateColonyStake(filter: ModelSubscriptionColonyStakeFilterInput): ColonyStake
  onDeleteColonyStake(filter: ModelSubscriptionColonyStakeFilterInput): ColonyStake
  onCreateDomain(filter: ModelSubscriptionDomainFilterInput): Domain
  onUpdateDomain(filter: ModelSubscriptionDomainFilterInput): Domain
  onDeleteDomain(filter: ModelSubscriptionDomainFilterInput): Domain
  onCreateDomainMetadata(filter: ModelSubscriptionDomainMetadataFilterInput): DomainMetadata
  onUpdateDomainMetadata(filter: ModelSubscriptionDomainMetadataFilterInput): DomainMetadata
  onDeleteDomainMetadata(filter: ModelSubscriptionDomainMetadataFilterInput): DomainMetadata
  onCreateColonyFundsClaim(filter: ModelSubscriptionColonyFundsClaimFilterInput): ColonyFundsClaim
  onUpdateColonyFundsClaim(filter: ModelSubscriptionColonyFundsClaimFilterInput): ColonyFundsClaim
  onDeleteColonyFundsClaim(filter: ModelSubscriptionColonyFundsClaimFilterInput): ColonyFundsClaim
  onCreateMotionMessage(filter: ModelSubscriptionMotionMessageFilterInput): MotionMessage
  onUpdateMotionMessage(filter: ModelSubscriptionMotionMessageFilterInput): MotionMessage
  onDeleteMotionMessage(filter: ModelSubscriptionMotionMessageFilterInput): MotionMessage
  onCreateColonyMotion(filter: ModelSubscriptionColonyMotionFilterInput): ColonyMotion
  onUpdateColonyMotion(filter: ModelSubscriptionColonyMotionFilterInput): ColonyMotion
  onDeleteColonyMotion(filter: ModelSubscriptionColonyMotionFilterInput): ColonyMotion
  onCreateContractEvent(filter: ModelSubscriptionContractEventFilterInput): ContractEvent
  onUpdateContractEvent(filter: ModelSubscriptionContractEventFilterInput): ContractEvent
  onDeleteContractEvent(filter: ModelSubscriptionContractEventFilterInput): ContractEvent
  onCreateColonyExtension(filter: ModelSubscriptionColonyExtensionFilterInput): ColonyExtension
  onUpdateColonyExtension(filter: ModelSubscriptionColonyExtensionFilterInput): ColonyExtension
  onDeleteColonyExtension(filter: ModelSubscriptionColonyExtensionFilterInput): ColonyExtension
  onCreateCurrentVersion(filter: ModelSubscriptionCurrentVersionFilterInput): CurrentVersion
  onUpdateCurrentVersion(filter: ModelSubscriptionCurrentVersionFilterInput): CurrentVersion
  onDeleteCurrentVersion(filter: ModelSubscriptionCurrentVersionFilterInput): CurrentVersion
  onCreateCurrentNetworkInverseFee(filter: ModelSubscriptionCurrentNetworkInverseFeeFilterInput): CurrentNetworkInverseFee
  onUpdateCurrentNetworkInverseFee(filter: ModelSubscriptionCurrentNetworkInverseFeeFilterInput): CurrentNetworkInverseFee
  onDeleteCurrentNetworkInverseFee(filter: ModelSubscriptionCurrentNetworkInverseFeeFilterInput): CurrentNetworkInverseFee
  onCreateColonyAction(filter: ModelSubscriptionColonyActionFilterInput): ColonyAction
  onUpdateColonyAction(filter: ModelSubscriptionColonyActionFilterInput): ColonyAction
  onDeleteColonyAction(filter: ModelSubscriptionColonyActionFilterInput): ColonyAction
  onCreateColonyDecision(filter: ModelSubscriptionColonyDecisionFilterInput): ColonyDecision
  onUpdateColonyDecision(filter: ModelSubscriptionColonyDecisionFilterInput): ColonyDecision
  onDeleteColonyDecision(filter: ModelSubscriptionColonyDecisionFilterInput): ColonyDecision
  onCreateColonyRole(filter: ModelSubscriptionColonyRoleFilterInput): ColonyRole
  onUpdateColonyRole(filter: ModelSubscriptionColonyRoleFilterInput): ColonyRole
  onDeleteColonyRole(filter: ModelSubscriptionColonyRoleFilterInput): ColonyRole
  onCreateColonyHistoricRole(filter: ModelSubscriptionColonyHistoricRoleFilterInput): ColonyHistoricRole
  onUpdateColonyHistoricRole(filter: ModelSubscriptionColonyHistoricRoleFilterInput): ColonyHistoricRole
  onDeleteColonyHistoricRole(filter: ModelSubscriptionColonyHistoricRoleFilterInput): ColonyHistoricRole
  onCreateIngestorStats(filter: ModelSubscriptionIngestorStatsFilterInput): IngestorStats
  onUpdateIngestorStats(filter: ModelSubscriptionIngestorStatsFilterInput): IngestorStats
  onDeleteIngestorStats(filter: ModelSubscriptionIngestorStatsFilterInput): IngestorStats
  onCreateExpenditure(filter: ModelSubscriptionExpenditureFilterInput): Expenditure
  onUpdateExpenditure(filter: ModelSubscriptionExpenditureFilterInput): Expenditure
  onDeleteExpenditure(filter: ModelSubscriptionExpenditureFilterInput): Expenditure
  onCreateAnnotation(filter: ModelSubscriptionAnnotationFilterInput): Annotation
  onUpdateAnnotation(filter: ModelSubscriptionAnnotationFilterInput): Annotation
  onDeleteAnnotation(filter: ModelSubscriptionAnnotationFilterInput): Annotation
  onCreateSafeTransaction(filter: ModelSubscriptionSafeTransactionFilterInput): SafeTransaction
  onUpdateSafeTransaction(filter: ModelSubscriptionSafeTransactionFilterInput): SafeTransaction
  onDeleteSafeTransaction(filter: ModelSubscriptionSafeTransactionFilterInput): SafeTransaction
  onCreateColonyTokens(filter: ModelSubscriptionColonyTokensFilterInput): ColonyTokens
  onUpdateColonyTokens(filter: ModelSubscriptionColonyTokensFilterInput): ColonyTokens
  onDeleteColonyTokens(filter: ModelSubscriptionColonyTokensFilterInput): ColonyTokens
  onCreateUserTokens(filter: ModelSubscriptionUserTokensFilterInput): UserTokens
  onUpdateUserTokens(filter: ModelSubscriptionUserTokensFilterInput): UserTokens
  onDeleteUserTokens(filter: ModelSubscriptionUserTokensFilterInput): UserTokens
  onCreateWatchedColonies(filter: ModelSubscriptionWatchedColoniesFilterInput): WatchedColonies
  onUpdateWatchedColonies(filter: ModelSubscriptionWatchedColoniesFilterInput): WatchedColonies
  onDeleteWatchedColonies(filter: ModelSubscriptionWatchedColoniesFilterInput): WatchedColonies
}

type ModelTokenConnection {
  items: [Token]!
  nextToken: String
}

input ModelTokenTypeInput {
  eq: TokenType
  ne: TokenType
}

input ModelTokenFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  symbol: ModelStringInput
  decimals: ModelIntInput
  type: ModelTokenTypeInput
  avatar: ModelStringInput
  thumbnail: ModelStringInput
  createdAt: ModelStringInput
  and: [ModelTokenFilterInput]
  or: [ModelTokenFilterInput]
  not: ModelTokenFilterInput
}

input ModelTokenConditionInput {
  name: ModelStringInput
  symbol: ModelStringInput
  decimals: ModelIntInput
  type: ModelTokenTypeInput
  avatar: ModelStringInput
  thumbnail: ModelStringInput
  createdAt: ModelStringInput
  and: [ModelTokenConditionInput]
  or: [ModelTokenConditionInput]
  not: ModelTokenConditionInput
}

input CreateTokenInput {
  id: ID
  name: String!
  symbol: String!
  decimals: Int!
  type: TokenType
  avatar: String
  thumbnail: String
  chainMetadata: ChainMetadataInput!
  createdAt: AWSDateTime
}

input UpdateTokenInput {
  id: ID!
  name: String
  symbol: String
  decimals: Int
  type: TokenType
  avatar: String
  thumbnail: String
  chainMetadata: ChainMetadataInput
  createdAt: AWSDateTime
}

input DeleteTokenInput {
  id: ID!
}

input ModelSubscriptionTokenFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  symbol: ModelSubscriptionStringInput
  decimals: ModelSubscriptionIntInput
  type: ModelSubscriptionStringInput
  avatar: ModelSubscriptionStringInput
  thumbnail: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionTokenFilterInput]
  or: [ModelSubscriptionTokenFilterInput]
}

input ColonyChainFundsClaimInput {
  id: ID
  createdAtBlock: Int!
  createdAt: AWSDateTime
  updatedAt: AWSDateTime
  amount: String!
}

input ColonyBalancesInput {
  items: [ColonyBalanceInput]
}

input ColonyBalanceInput {
  id: ID
  balance: String!
  domain: DomainInput
  token: TokenInput!
}

input ColonyUnclaimedStakeInput {
  motionId: String!
  unclaimedRewards: [StakerRewardsInput!]!
}

type ModelColonyConnection {
  items: [Colony]!
  nextToken: String
}

input ModelColonyTypeInput {
  eq: ColonyType
  ne: ColonyType
}

input ModelColonyFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  nativeTokenId: ModelIDInput
  type: ModelColonyTypeInput
  version: ModelIntInput
  expendituresGlobalClaimDelay: ModelIntInput
  and: [ModelColonyFilterInput]
  or: [ModelColonyFilterInput]
  not: ModelColonyFilterInput
}

input ModelColonyConditionInput {
  name: ModelStringInput
  nativeTokenId: ModelIDInput
  type: ModelColonyTypeInput
  version: ModelIntInput
  expendituresGlobalClaimDelay: ModelIntInput
  and: [ModelColonyConditionInput]
  or: [ModelColonyConditionInput]
  not: ModelColonyConditionInput
}

input CreateColonyInput {
  id: ID
  name: String!
  nativeTokenId: ID!
  status: ColonyStatusInput
  chainFundsClaim: ColonyChainFundsClaimInput
  type: ColonyType
  balances: ColonyBalancesInput
  chainMetadata: ChainMetadataInput!
  version: Int!
  motionsWithUnclaimedStakes: [ColonyUnclaimedStakeInput!]
  expendituresGlobalClaimDelay: Int
}

input UpdateColonyInput {
  id: ID!
  name: String
  nativeTokenId: ID
  status: ColonyStatusInput
  chainFundsClaim: ColonyChainFundsClaimInput
  type: ColonyType
  balances: ColonyBalancesInput
  chainMetadata: ChainMetadataInput
  version: Int
  motionsWithUnclaimedStakes: [ColonyUnclaimedStakeInput!]
  expendituresGlobalClaimDelay: Int
}

input DeleteColonyInput {
  id: ID!
}

input ModelSubscriptionColonyFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  nativeTokenId: ModelSubscriptionIDInput
  type: ModelSubscriptionStringInput
  version: ModelSubscriptionIntInput
  expendituresGlobalClaimDelay: ModelSubscriptionIntInput
  and: [ModelSubscriptionColonyFilterInput]
  or: [ModelSubscriptionColonyFilterInput]
}

input ColonyMetadataChangelogInput {
  transactionHash: String!
  oldDisplayName: String!
  newDisplayName: String!
  hasAvatarChanged: Boolean!
  hasWhitelistChanged: Boolean!
  haveTokensChanged: Boolean!
  newSafes: [SafeInput!]
  oldSafes: [SafeInput!]
}

input SafeInput {
  name: String!
  address: String!
  chainId: Int!
  moduleContractAddress: String!
}

input PendingModifiedTokenAddressesInput {
  added: [String!]
  removed: [String!]
}

type ModelColonyMetadataConnection {
  items: [ColonyMetadata]!
  nextToken: String
}

input ModelColonyMetadataFilterInput {
  id: ModelIDInput
  displayName: ModelStringInput
  avatar: ModelStringInput
  thumbnail: ModelStringInput
  isWhitelistActivated: ModelBooleanInput
  whitelistedAddresses: ModelStringInput
  and: [ModelColonyMetadataFilterInput]
  or: [ModelColonyMetadataFilterInput]
  not: ModelColonyMetadataFilterInput
}

input ModelColonyMetadataConditionInput {
  displayName: ModelStringInput
  avatar: ModelStringInput
  thumbnail: ModelStringInput
  isWhitelistActivated: ModelBooleanInput
  whitelistedAddresses: ModelStringInput
  and: [ModelColonyMetadataConditionInput]
  or: [ModelColonyMetadataConditionInput]
  not: ModelColonyMetadataConditionInput
}

input CreateColonyMetadataInput {
  id: ID
  displayName: String!
  avatar: String
  thumbnail: String
  changelog: [ColonyMetadataChangelogInput!]
  isWhitelistActivated: Boolean
  whitelistedAddresses: [String!]
  modifiedTokenAddresses: PendingModifiedTokenAddressesInput
  safes: [SafeInput!]
}

input UpdateColonyMetadataInput {
  id: ID!
  displayName: String
  avatar: String
  thumbnail: String
  changelog: [ColonyMetadataChangelogInput!]
  isWhitelistActivated: Boolean
  whitelistedAddresses: [String!]
  modifiedTokenAddresses: PendingModifiedTokenAddressesInput
  safes: [SafeInput!]
}

input DeleteColonyMetadataInput {
  id: ID!
}

input ModelSubscriptionColonyMetadataFilterInput {
  id: ModelSubscriptionIDInput
  displayName: ModelSubscriptionStringInput
  avatar: ModelSubscriptionStringInput
  thumbnail: ModelSubscriptionStringInput
  isWhitelistActivated: ModelSubscriptionBooleanInput
  whitelistedAddresses: ModelSubscriptionStringInput
  and: [ModelSubscriptionColonyMetadataFilterInput]
  or: [ModelSubscriptionColonyMetadataFilterInput]
}

type ModelUserConnection {
  items: [User]!
  nextToken: String
}

input ModelUserFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  profileId: ModelIDInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

input ModelUserConditionInput {
  name: ModelStringInput
  profileId: ModelIDInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
}

input CreateUserInput {
  id: ID
  name: String!
  profileId: ID
}

input UpdateUserInput {
  id: ID!
  name: String
  profileId: ID
}

input DeleteUserInput {
  id: ID!
}

input ModelSubscriptionUserFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  profileId: ModelSubscriptionIDInput
  and: [ModelSubscriptionUserFilterInput]
  or: [ModelSubscriptionUserFilterInput]
}

type ModelColonyStakeConnection {
  items: [ColonyStake]!
  nextToken: String
}

input ModelColonyStakeFilterInput {
  id: ModelIDInput
  userId: ModelIDInput
  colonyId: ModelIDInput
  totalAmount: ModelStringInput
  and: [ModelColonyStakeFilterInput]
  or: [ModelColonyStakeFilterInput]
  not: ModelColonyStakeFilterInput
}

input ModelColonyStakeConditionInput {
  userId: ModelIDInput
  colonyId: ModelIDInput
  totalAmount: ModelStringInput
  and: [ModelColonyStakeConditionInput]
  or: [ModelColonyStakeConditionInput]
  not: ModelColonyStakeConditionInput
}

input CreateColonyStakeInput {
  id: ID
  userId: ID!
  colonyId: ID!
  totalAmount: String!
}

input UpdateColonyStakeInput {
  id: ID!
  userId: ID
  colonyId: ID
  totalAmount: String
}

input DeleteColonyStakeInput {
  id: ID!
}

input ModelSubscriptionColonyStakeFilterInput {
  id: ModelSubscriptionIDInput
  userId: ModelSubscriptionIDInput
  colonyId: ModelSubscriptionIDInput
  totalAmount: ModelSubscriptionStringInput
  and: [ModelSubscriptionColonyStakeFilterInput]
  or: [ModelSubscriptionColonyStakeFilterInput]
}

type ModelDomainConnection {
  items: [Domain]!
  nextToken: String
}

input ModelDomainFilterInput {
  id: ModelIDInput
  colonyId: ModelIDInput
  nativeId: ModelIntInput
  nativeFundingPotId: ModelIntInput
  nativeSkillId: ModelIntInput
  isRoot: ModelBooleanInput
  and: [ModelDomainFilterInput]
  or: [ModelDomainFilterInput]
  not: ModelDomainFilterInput
}

input ModelDomainConditionInput {
  colonyId: ModelIDInput
  nativeId: ModelIntInput
  nativeFundingPotId: ModelIntInput
  nativeSkillId: ModelIntInput
  isRoot: ModelBooleanInput
  and: [ModelDomainConditionInput]
  or: [ModelDomainConditionInput]
  not: ModelDomainConditionInput
}

input CreateDomainInput {
  id: ID
  colonyId: ID!
  nativeId: Int!
  nativeFundingPotId: Int!
  nativeSkillId: Int!
  isRoot: Boolean!
}

input UpdateDomainInput {
  id: ID!
  colonyId: ID
  nativeId: Int
  nativeFundingPotId: Int
  nativeSkillId: Int
  isRoot: Boolean
}

input DeleteDomainInput {
  id: ID!
}

input ModelSubscriptionDomainFilterInput {
  id: ModelSubscriptionIDInput
  colonyId: ModelSubscriptionIDInput
  nativeId: ModelSubscriptionIntInput
  nativeFundingPotId: ModelSubscriptionIntInput
  nativeSkillId: ModelSubscriptionIntInput
  isRoot: ModelSubscriptionBooleanInput
  and: [ModelSubscriptionDomainFilterInput]
  or: [ModelSubscriptionDomainFilterInput]
}

input DomainMetadataChangelogInput {
  transactionHash: String!
  oldName: String!
  newName: String!
  oldColor: DomainColor!
  newColor: DomainColor!
  oldDescription: String!
  newDescription: String!
}

type ModelDomainMetadataConnection {
  items: [DomainMetadata]!
  nextToken: String
}

input ModelDomainColorInput {
  eq: DomainColor
  ne: DomainColor
}

input ModelDomainMetadataFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  color: ModelDomainColorInput
  and: [ModelDomainMetadataFilterInput]
  or: [ModelDomainMetadataFilterInput]
  not: ModelDomainMetadataFilterInput
}

input ModelDomainMetadataConditionInput {
  name: ModelStringInput
  description: ModelStringInput
  color: ModelDomainColorInput
  and: [ModelDomainMetadataConditionInput]
  or: [ModelDomainMetadataConditionInput]
  not: ModelDomainMetadataConditionInput
}

input CreateDomainMetadataInput {
  id: ID
  name: String!
  description: String!
  color: DomainColor!
  changelog: [DomainMetadataChangelogInput!]
}

input UpdateDomainMetadataInput {
  id: ID!
  name: String
  description: String
  color: DomainColor
  changelog: [DomainMetadataChangelogInput!]
}

input DeleteDomainMetadataInput {
  id: ID!
}

input ModelSubscriptionDomainMetadataFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  description: ModelSubscriptionStringInput
  color: ModelSubscriptionStringInput
  and: [ModelSubscriptionDomainMetadataFilterInput]
  or: [ModelSubscriptionDomainMetadataFilterInput]
}

type ModelColonyFundsClaimConnection {
  items: [ColonyFundsClaim]!
  nextToken: String
}

input ModelColonyFundsClaimFilterInput {
  id: ModelIDInput
  createdAtBlock: ModelIntInput
  createdAt: ModelStringInput
  amount: ModelStringInput
  and: [ModelColonyFundsClaimFilterInput]
  or: [ModelColonyFundsClaimFilterInput]
  not: ModelColonyFundsClaimFilterInput
  colonyFundsClaimsId: ModelIDInput
  colonyFundsClaimTokenId: ModelIDInput
}

input ModelColonyFundsClaimConditionInput {
  createdAtBlock: ModelIntInput
  createdAt: ModelStringInput
  amount: ModelStringInput
  and: [ModelColonyFundsClaimConditionInput]
  or: [ModelColonyFundsClaimConditionInput]
  not: ModelColonyFundsClaimConditionInput
  colonyFundsClaimsId: ModelIDInput
  colonyFundsClaimTokenId: ModelIDInput
}

input CreateColonyFundsClaimInput {
  id: ID
  createdAtBlock: Int!
  createdAt: AWSDateTime
  amount: String!
  colonyFundsClaimsId: ID
  colonyFundsClaimTokenId: ID!
}

input UpdateColonyFundsClaimInput {
  id: ID!
  createdAtBlock: Int
  createdAt: AWSDateTime
  amount: String
  colonyFundsClaimsId: ID
  colonyFundsClaimTokenId: ID
}

input DeleteColonyFundsClaimInput {
  id: ID!
}

input ModelSubscriptionColonyFundsClaimFilterInput {
  id: ModelSubscriptionIDInput
  createdAtBlock: ModelSubscriptionIntInput
  createdAt: ModelSubscriptionStringInput
  amount: ModelSubscriptionStringInput
  and: [ModelSubscriptionColonyFundsClaimFilterInput]
  or: [ModelSubscriptionColonyFundsClaimFilterInput]
}

type ModelMotionMessageConnection {
  items: [MotionMessage]!
  nextToken: String
}

input ModelMotionMessageFilterInput {
  initiatorAddress: ModelIDInput
  name: ModelStringInput
  messageKey: ModelStringInput
  motionId: ModelIDInput
  vote: ModelStringInput
  amount: ModelStringInput
  createdAt: ModelStringInput
  and: [ModelMotionMessageFilterInput]
  or: [ModelMotionMessageFilterInput]
  not: ModelMotionMessageFilterInput
}

input ModelMotionMessageConditionInput {
  initiatorAddress: ModelIDInput
  name: ModelStringInput
  messageKey: ModelStringInput
  motionId: ModelIDInput
  vote: ModelStringInput
  amount: ModelStringInput
  createdAt: ModelStringInput
  and: [ModelMotionMessageConditionInput]
  or: [ModelMotionMessageConditionInput]
  not: ModelMotionMessageConditionInput
}

input CreateMotionMessageInput {
  initiatorAddress: ID!
  name: String!
  messageKey: String!
  motionId: ID!
  vote: String
  amount: String
  createdAt: AWSDateTime
  id: ID
}

input UpdateMotionMessageInput {
  initiatorAddress: ID
  name: String
  messageKey: String
  motionId: ID
  vote: String
  amount: String
  createdAt: AWSDateTime
  id: ID!
}

input DeleteMotionMessageInput {
  id: ID!
}

input ModelSubscriptionMotionMessageFilterInput {
  initiatorAddress: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  messageKey: ModelSubscriptionStringInput
  motionId: ModelSubscriptionIDInput
  vote: ModelSubscriptionStringInput
  amount: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionMotionMessageFilterInput]
  or: [ModelSubscriptionMotionMessageFilterInput]
}

type ModelColonyMotionConnection {
  items: [ColonyMotion]!
  nextToken: String
}

input ModelColonyMotionFilterInput {
  id: ModelIDInput
  nativeMotionId: ModelStringInput
  remainingStakes: ModelStringInput
  userMinStake: ModelStringInput
  requiredStake: ModelStringInput
  motionDomainId: ModelIDInput
  rootHash: ModelStringInput
  nativeMotionDomainId: ModelStringInput
  isFinalized: ModelBooleanInput
  createdBy: ModelStringInput
  repSubmitted: ModelStringInput
  skillRep: ModelStringInput
  hasObjection: ModelBooleanInput
  objectionAnnotationId: ModelIDInput
  isDecision: ModelBooleanInput
  and: [ModelColonyMotionFilterInput]
  or: [ModelColonyMotionFilterInput]
  not: ModelColonyMotionFilterInput
}

input ModelColonyMotionConditionInput {
  nativeMotionId: ModelStringInput
  remainingStakes: ModelStringInput
  userMinStake: ModelStringInput
  requiredStake: ModelStringInput
  motionDomainId: ModelIDInput
  rootHash: ModelStringInput
  nativeMotionDomainId: ModelStringInput
  isFinalized: ModelBooleanInput
  createdBy: ModelStringInput
  repSubmitted: ModelStringInput
  skillRep: ModelStringInput
  hasObjection: ModelBooleanInput
  objectionAnnotationId: ModelIDInput
  isDecision: ModelBooleanInput
  and: [ModelColonyMotionConditionInput]
  or: [ModelColonyMotionConditionInput]
  not: ModelColonyMotionConditionInput
}

input CreateColonyMotionInput {
  id: ID
  nativeMotionId: String!
  usersStakes: [UserStakesInput!]!
  stakerRewards: [StakerRewardsInput!]!
  motionStakes: MotionStakesInput!
  remainingStakes: [String!]!
  userMinStake: String!
  requiredStake: String!
  motionDomainId: ID!
  rootHash: String!
  nativeMotionDomainId: String!
  isFinalized: Boolean!
  createdBy: String!
  voterRecord: [VoterRecordInput!]!
  revealedVotes: MotionStakesInput!
  repSubmitted: String!
  skillRep: String!
  hasObjection: Boolean!
  motionStateHistory: MotionStateHistoryInput!
  objectionAnnotationId: ID
  isDecision: Boolean!
}

input UpdateColonyMotionInput {
  id: ID!
  nativeMotionId: String
  usersStakes: [UserStakesInput!]
  stakerRewards: [StakerRewardsInput!]
  motionStakes: MotionStakesInput
  remainingStakes: [String!]
  userMinStake: String
  requiredStake: String
  motionDomainId: ID
  rootHash: String
  nativeMotionDomainId: String
  isFinalized: Boolean
  createdBy: String
  voterRecord: [VoterRecordInput!]
  revealedVotes: MotionStakesInput
  repSubmitted: String
  skillRep: String
  hasObjection: Boolean
  motionStateHistory: MotionStateHistoryInput
  objectionAnnotationId: ID
  isDecision: Boolean
}

input DeleteColonyMotionInput {
  id: ID!
}

input ModelSubscriptionColonyMotionFilterInput {
  id: ModelSubscriptionIDInput
  nativeMotionId: ModelSubscriptionStringInput
  remainingStakes: ModelSubscriptionStringInput
  userMinStake: ModelSubscriptionStringInput
  requiredStake: ModelSubscriptionStringInput
  motionDomainId: ModelSubscriptionIDInput
  rootHash: ModelSubscriptionStringInput
  nativeMotionDomainId: ModelSubscriptionStringInput
  isFinalized: ModelSubscriptionBooleanInput
  createdBy: ModelSubscriptionStringInput
  repSubmitted: ModelSubscriptionStringInput
  skillRep: ModelSubscriptionStringInput
  hasObjection: ModelSubscriptionBooleanInput
  objectionAnnotationId: ModelSubscriptionIDInput
  isDecision: ModelSubscriptionBooleanInput
  and: [ModelSubscriptionColonyMotionFilterInput]
  or: [ModelSubscriptionColonyMotionFilterInput]
}

type ModelContractEventConnection {
  items: [ContractEvent]!
  nextToken: String
}

input ModelContractEventFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  signature: ModelStringInput
  agent: ModelStringInput
  target: ModelStringInput
  encodedArguments: ModelStringInput
  and: [ModelContractEventFilterInput]
  or: [ModelContractEventFilterInput]
  not: ModelContractEventFilterInput
  contractEventColonyId: ModelIDInput
  contractEventTokenId: ModelIDInput
  contractEventDomainId: ModelIDInput
  contractEventUserId: ModelIDInput
}

input ModelContractEventConditionInput {
  name: ModelStringInput
  signature: ModelStringInput
  agent: ModelStringInput
  target: ModelStringInput
  encodedArguments: ModelStringInput
  and: [ModelContractEventConditionInput]
  or: [ModelContractEventConditionInput]
  not: ModelContractEventConditionInput
  contractEventColonyId: ModelIDInput
  contractEventTokenId: ModelIDInput
  contractEventDomainId: ModelIDInput
  contractEventUserId: ModelIDInput
}

input CreateContractEventInput {
  id: ID
  name: String!
  signature: String!
  chainMetadata: ChainMetadataInput!
  agent: String!
  target: String!
  encodedArguments: String
  contractEventColonyId: ID
  contractEventTokenId: ID
  contractEventDomainId: ID
  contractEventUserId: ID
}

input UpdateContractEventInput {
  id: ID!
  name: String
  signature: String
  chainMetadata: ChainMetadataInput
  agent: String
  target: String
  encodedArguments: String
  contractEventColonyId: ID
  contractEventTokenId: ID
  contractEventDomainId: ID
  contractEventUserId: ID
}

input DeleteContractEventInput {
  id: ID!
}

input ModelSubscriptionContractEventFilterInput {
  id: ModelSubscriptionIDInput
  name: ModelSubscriptionStringInput
  signature: ModelSubscriptionStringInput
  agent: ModelSubscriptionStringInput
  target: ModelSubscriptionStringInput
  encodedArguments: ModelSubscriptionStringInput
  and: [ModelSubscriptionContractEventFilterInput]
  or: [ModelSubscriptionContractEventFilterInput]
}

input ExtensionParamsInput {
  votingReputation: VotingReputationParamsInput
}

input VotingReputationParamsInput {
  totalStakeFraction: String!
  voterRewardFraction: String!
  userMinStakeFraction: String!
  maxVoteFraction: String!
  stakePeriod: String!
  submitPeriod: String!
  revealPeriod: String!
  escalationPeriod: String!
}

type ModelColonyExtensionConnection {
  items: [ColonyExtension]!
  nextToken: String
}

input ModelColonyExtensionFilterInput {
  id: ModelIDInput
  colonyId: ModelIDInput
  hash: ModelStringInput
  installedBy: ModelStringInput
  installedAt: ModelIntInput
  isDeprecated: ModelBooleanInput
  isDeleted: ModelBooleanInput
  isInitialized: ModelBooleanInput
  version: ModelIntInput
  and: [ModelColonyExtensionFilterInput]
  or: [ModelColonyExtensionFilterInput]
  not: ModelColonyExtensionFilterInput
}

input ModelColonyExtensionConditionInput {
  colonyId: ModelIDInput
  hash: ModelStringInput
  installedBy: ModelStringInput
  installedAt: ModelIntInput
  isDeprecated: ModelBooleanInput
  isDeleted: ModelBooleanInput
  isInitialized: ModelBooleanInput
  version: ModelIntInput
  and: [ModelColonyExtensionConditionInput]
  or: [ModelColonyExtensionConditionInput]
  not: ModelColonyExtensionConditionInput
}

input CreateColonyExtensionInput {
  id: ID
  colonyId: ID!
  hash: String!
  installedBy: String!
  installedAt: AWSTimestamp!
  isDeprecated: Boolean!
  isDeleted: Boolean!
  isInitialized: Boolean!
  version: Int!
  params: ExtensionParamsInput
}

input UpdateColonyExtensionInput {
  id: ID!
  colonyId: ID
  hash: String
  installedBy: String
  installedAt: AWSTimestamp
  isDeprecated: Boolean
  isDeleted: Boolean
  isInitialized: Boolean
  version: Int
  params: ExtensionParamsInput
}

input DeleteColonyExtensionInput {
  id: ID!
}

input ModelSubscriptionColonyExtensionFilterInput {
  id: ModelSubscriptionIDInput
  colonyId: ModelSubscriptionIDInput
  hash: ModelSubscriptionStringInput
  installedBy: ModelSubscriptionStringInput
  installedAt: ModelSubscriptionIntInput
  isDeprecated: ModelSubscriptionBooleanInput
  isDeleted: ModelSubscriptionBooleanInput
  isInitialized: ModelSubscriptionBooleanInput
  version: ModelSubscriptionIntInput
  and: [ModelSubscriptionColonyExtensionFilterInput]
  or: [ModelSubscriptionColonyExtensionFilterInput]
}

type ModelCurrentVersionConnection {
  items: [CurrentVersion]!
  nextToken: String
}

input ModelCurrentVersionFilterInput {
  id: ModelIDInput
  key: ModelStringInput
  version: ModelIntInput
  and: [ModelCurrentVersionFilterInput]
  or: [ModelCurrentVersionFilterInput]
  not: ModelCurrentVersionFilterInput
}

input ModelCurrentVersionConditionInput {
  key: ModelStringInput
  version: ModelIntInput
  and: [ModelCurrentVersionConditionInput]
  or: [ModelCurrentVersionConditionInput]
  not: ModelCurrentVersionConditionInput
}

input CreateCurrentVersionInput {
  id: ID
  key: String!
  version: Int!
}

input UpdateCurrentVersionInput {
  id: ID!
  key: String
  version: Int
}

input DeleteCurrentVersionInput {
  id: ID!
}

input ModelSubscriptionCurrentVersionFilterInput {
  id: ModelSubscriptionIDInput
  key: ModelSubscriptionStringInput
  version: ModelSubscriptionIntInput
  and: [ModelSubscriptionCurrentVersionFilterInput]
  or: [ModelSubscriptionCurrentVersionFilterInput]
}

type ModelCurrentNetworkInverseFeeConnection {
  items: [CurrentNetworkInverseFee]!
  nextToken: String
}

input ModelCurrentNetworkInverseFeeFilterInput {
  id: ModelIDInput
  inverseFee: ModelStringInput
  and: [ModelCurrentNetworkInverseFeeFilterInput]
  or: [ModelCurrentNetworkInverseFeeFilterInput]
  not: ModelCurrentNetworkInverseFeeFilterInput
}

input ModelCurrentNetworkInverseFeeConditionInput {
  inverseFee: ModelStringInput
  and: [ModelCurrentNetworkInverseFeeConditionInput]
  or: [ModelCurrentNetworkInverseFeeConditionInput]
  not: ModelCurrentNetworkInverseFeeConditionInput
}

input CreateCurrentNetworkInverseFeeInput {
  id: ID
  inverseFee: String!
}

input UpdateCurrentNetworkInverseFeeInput {
  id: ID!
  inverseFee: String
}

input DeleteCurrentNetworkInverseFeeInput {
  id: ID!
}

input ModelSubscriptionCurrentNetworkInverseFeeFilterInput {
  id: ModelSubscriptionIDInput
  inverseFee: ModelSubscriptionStringInput
  and: [ModelSubscriptionCurrentNetworkInverseFeeFilterInput]
  or: [ModelSubscriptionCurrentNetworkInverseFeeFilterInput]
}

input ColonyActionRolesInput {
  role_0: Boolean
  role_1: Boolean
  role_2: Boolean
  role_3: Boolean
  role_5: Boolean
  role_6: Boolean
}

type ModelColonyActionConnection {
  items: [ColonyAction]!
  nextToken: String
}

input ModelColonyActionTypeInput {
  eq: ColonyActionType
  ne: ColonyActionType
}

input ModelColonyActionFilterInput {
  id: ModelIDInput
  colonyId: ModelIDInput
  type: ModelColonyActionTypeInput
  blockNumber: ModelIntInput
  isMotion: ModelBooleanInput
  motionId: ModelIDInput
  showInActionsList: ModelBooleanInput
  createdAt: ModelStringInput
  initiatorAddress: ModelIDInput
  recipientAddress: ModelIDInput
  amount: ModelStringInput
  tokenAddress: ModelIDInput
  fromDomainId: ModelIDInput
  toDomainId: ModelIDInput
  fundamentalChainId: ModelIntInput
  newColonyVersion: ModelIntInput
  pendingDomainMetadataId: ModelIDInput
  pendingColonyMetadataId: ModelIDInput
  annotationId: ModelIDInput
  motionDomainId: ModelIntInput
  colonyDecisionId: ModelIDInput
  individualEvents: ModelStringInput
  and: [ModelColonyActionFilterInput]
  or: [ModelColonyActionFilterInput]
  not: ModelColonyActionFilterInput
  colonyActionsId: ModelIDInput
}

input ModelColonyActionConditionInput {
  colonyId: ModelIDInput
  type: ModelColonyActionTypeInput
  blockNumber: ModelIntInput
  isMotion: ModelBooleanInput
  motionId: ModelIDInput
  showInActionsList: ModelBooleanInput
  createdAt: ModelStringInput
  initiatorAddress: ModelIDInput
  recipientAddress: ModelIDInput
  amount: ModelStringInput
  tokenAddress: ModelIDInput
  fromDomainId: ModelIDInput
  toDomainId: ModelIDInput
  fundamentalChainId: ModelIntInput
  newColonyVersion: ModelIntInput
  pendingDomainMetadataId: ModelIDInput
  pendingColonyMetadataId: ModelIDInput
  annotationId: ModelIDInput
  motionDomainId: ModelIntInput
  colonyDecisionId: ModelIDInput
  individualEvents: ModelStringInput
  and: [ModelColonyActionConditionInput]
  or: [ModelColonyActionConditionInput]
  not: ModelColonyActionConditionInput
  colonyActionsId: ModelIDInput
}

input CreateColonyActionInput {
  id: ID
  colonyId: ID!
  type: ColonyActionType!
  blockNumber: Int!
  isMotion: Boolean
  motionId: ID
  showInActionsList: Boolean!
  createdAt: AWSDateTime
  initiatorAddress: ID!
  recipientAddress: ID
  amount: String
  tokenAddress: ID
  fromDomainId: ID
  toDomainId: ID
  fundamentalChainId: Int
  newColonyVersion: Int
  pendingDomainMetadataId: ID
  pendingColonyMetadataId: ID
  annotationId: ID
  motionDomainId: Int
  colonyDecisionId: ID
  roles: ColonyActionRolesInput
  individualEvents: String
  colonyActionsId: ID
}

input UpdateColonyActionInput {
  id: ID!
  colonyId: ID
  type: ColonyActionType
  blockNumber: Int
  isMotion: Boolean
  motionId: ID
  showInActionsList: Boolean
  createdAt: AWSDateTime
  initiatorAddress: ID
  recipientAddress: ID
  amount: String
  tokenAddress: ID
  fromDomainId: ID
  toDomainId: ID
  fundamentalChainId: Int
  newColonyVersion: Int
  pendingDomainMetadataId: ID
  pendingColonyMetadataId: ID
  annotationId: ID
  motionDomainId: Int
  colonyDecisionId: ID
  roles: ColonyActionRolesInput
  individualEvents: String
  colonyActionsId: ID
}

input DeleteColonyActionInput {
  id: ID!
}

input ModelSubscriptionColonyActionFilterInput {
  id: ModelSubscriptionIDInput
  colonyId: ModelSubscriptionIDInput
  type: ModelSubscriptionStringInput
  blockNumber: ModelSubscriptionIntInput
  isMotion: ModelSubscriptionBooleanInput
  motionId: ModelSubscriptionIDInput
  showInActionsList: ModelSubscriptionBooleanInput
  createdAt: ModelSubscriptionStringInput
  initiatorAddress: ModelSubscriptionIDInput
  recipientAddress: ModelSubscriptionIDInput
  amount: ModelSubscriptionStringInput
  tokenAddress: ModelSubscriptionIDInput
  fromDomainId: ModelSubscriptionIDInput
  toDomainId: ModelSubscriptionIDInput
  fundamentalChainId: ModelSubscriptionIntInput
  newColonyVersion: ModelSubscriptionIntInput
  pendingDomainMetadataId: ModelSubscriptionIDInput
  pendingColonyMetadataId: ModelSubscriptionIDInput
  annotationId: ModelSubscriptionIDInput
  motionDomainId: ModelSubscriptionIntInput
  colonyDecisionId: ModelSubscriptionIDInput
  individualEvents: ModelSubscriptionStringInput
  and: [ModelSubscriptionColonyActionFilterInput]
  or: [ModelSubscriptionColonyActionFilterInput]
}

type ModelColonyDecisionConnection {
  items: [ColonyDecision]!
  nextToken: String
}

input ModelColonyDecisionFilterInput {
  id: ModelIDInput
  actionId: ModelIDInput
  title: ModelStringInput
  colonyAddress: ModelStringInput
  createdAt: ModelStringInput
  description: ModelStringInput
  motionDomainId: ModelIntInput
  walletAddress: ModelStringInput
  showInDecisionsList: ModelBooleanInput
  and: [ModelColonyDecisionFilterInput]
  or: [ModelColonyDecisionFilterInput]
  not: ModelColonyDecisionFilterInput
}

input ModelColonyDecisionConditionInput {
  actionId: ModelIDInput
  title: ModelStringInput
  colonyAddress: ModelStringInput
  createdAt: ModelStringInput
  description: ModelStringInput
  motionDomainId: ModelIntInput
  walletAddress: ModelStringInput
  showInDecisionsList: ModelBooleanInput
  and: [ModelColonyDecisionConditionInput]
  or: [ModelColonyDecisionConditionInput]
  not: ModelColonyDecisionConditionInput
}

input CreateColonyDecisionInput {
  id: ID
  actionId: ID!
  title: String!
  colonyAddress: String!
  createdAt: AWSDateTime
  description: String!
  motionDomainId: Int!
  walletAddress: String!
  showInDecisionsList: Boolean!
}

input UpdateColonyDecisionInput {
  id: ID!
  actionId: ID
  title: String
  colonyAddress: String
  createdAt: AWSDateTime
  description: String
  motionDomainId: Int
  walletAddress: String
  showInDecisionsList: Boolean
}

input DeleteColonyDecisionInput {
  id: ID!
}

input ModelSubscriptionColonyDecisionFilterInput {
  id: ModelSubscriptionIDInput
  actionId: ModelSubscriptionIDInput
  title: ModelSubscriptionStringInput
  colonyAddress: ModelSubscriptionStringInput
  createdAt: ModelSubscriptionStringInput
  description: ModelSubscriptionStringInput
  motionDomainId: ModelSubscriptionIntInput
  walletAddress: ModelSubscriptionStringInput
  showInDecisionsList: ModelSubscriptionBooleanInput
  and: [ModelSubscriptionColonyDecisionFilterInput]
  or: [ModelSubscriptionColonyDecisionFilterInput]
}

type ModelColonyRoleConnection {
  items: [ColonyRole]!
  nextToken: String
}

input ModelColonyRoleFilterInput {
  id: ModelIDInput
  domainId: ModelIDInput
  targetAddress: ModelIDInput
  latestBlock: ModelIntInput
  role_0: ModelBooleanInput
  role_1: ModelBooleanInput
  role_2: ModelBooleanInput
  role_3: ModelBooleanInput
  role_5: ModelBooleanInput
  role_6: ModelBooleanInput
  and: [ModelColonyRoleFilterInput]
  or: [ModelColonyRoleFilterInput]
  not: ModelColonyRoleFilterInput
  colonyRolesId: ModelIDInput
}

input ModelColonyRoleConditionInput {
  domainId: ModelIDInput
  targetAddress: ModelIDInput
  latestBlock: ModelIntInput
  role_0: ModelBooleanInput
  role_1: ModelBooleanInput
  role_2: ModelBooleanInput
  role_3: ModelBooleanInput
  role_5: ModelBooleanInput
  role_6: ModelBooleanInput
  and: [ModelColonyRoleConditionInput]
  or: [ModelColonyRoleConditionInput]
  not: ModelColonyRoleConditionInput
  colonyRolesId: ModelIDInput
}

input CreateColonyRoleInput {
  id: ID
  domainId: ID!
  targetAddress: ID
  latestBlock: Int!
  role_0: Boolean
  role_1: Boolean
  role_2: Boolean
  role_3: Boolean
  role_5: Boolean
  role_6: Boolean
  colonyRolesId: ID
}

input UpdateColonyRoleInput {
  id: ID!
  domainId: ID
  targetAddress: ID
  latestBlock: Int
  role_0: Boolean
  role_1: Boolean
  role_2: Boolean
  role_3: Boolean
  role_5: Boolean
  role_6: Boolean
  colonyRolesId: ID
}

input DeleteColonyRoleInput {
  id: ID!
}

input ModelSubscriptionColonyRoleFilterInput {
  id: ModelSubscriptionIDInput
  domainId: ModelSubscriptionIDInput
  targetAddress: ModelSubscriptionIDInput
  latestBlock: ModelSubscriptionIntInput
  role_0: ModelSubscriptionBooleanInput
  role_1: ModelSubscriptionBooleanInput
  role_2: ModelSubscriptionBooleanInput
  role_3: ModelSubscriptionBooleanInput
  role_5: ModelSubscriptionBooleanInput
  role_6: ModelSubscriptionBooleanInput
  and: [ModelSubscriptionColonyRoleFilterInput]
  or: [ModelSubscriptionColonyRoleFilterInput]
}

type ModelColonyHistoricRoleConnection {
  items: [ColonyHistoricRole]!
  nextToken: String
}

input ModelColonyHistoricRoleFilterInput {
  id: ModelIDInput
  type: ModelStringInput
  domainId: ModelIDInput
  colonyId: ModelIDInput
  targetAddress: ModelIDInput
  blockNumber: ModelIntInput
  role_0: ModelBooleanInput
  role_1: ModelBooleanInput
  role_2: ModelBooleanInput
  role_3: ModelBooleanInput
  role_5: ModelBooleanInput
  role_6: ModelBooleanInput
  createdAt: ModelStringInput
  and: [ModelColonyHistoricRoleFilterInput]
  or: [ModelColonyHistoricRoleFilterInput]
  not: ModelColonyHistoricRoleFilterInput
}

input ModelColonyHistoricRoleConditionInput {
  type: ModelStringInput
  domainId: ModelIDInput
  colonyId: ModelIDInput
  targetAddress: ModelIDInput
  blockNumber: ModelIntInput
  role_0: ModelBooleanInput
  role_1: ModelBooleanInput
  role_2: ModelBooleanInput
  role_3: ModelBooleanInput
  role_5: ModelBooleanInput
  role_6: ModelBooleanInput
  createdAt: ModelStringInput
  and: [ModelColonyHistoricRoleConditionInput]
  or: [ModelColonyHistoricRoleConditionInput]
  not: ModelColonyHistoricRoleConditionInput
}

input CreateColonyHistoricRoleInput {
  id: ID
  type: String!
  domainId: ID!
  colonyId: ID!
  targetAddress: ID
  blockNumber: Int!
  role_0: Boolean
  role_1: Boolean
  role_2: Boolean
  role_3: Boolean
  role_5: Boolean
  role_6: Boolean
  createdAt: AWSDateTime
}

input UpdateColonyHistoricRoleInput {
  id: ID!
  type: String
  domainId: ID
  colonyId: ID
  targetAddress: ID
  blockNumber: Int
  role_0: Boolean
  role_1: Boolean
  role_2: Boolean
  role_3: Boolean
  role_5: Boolean
  role_6: Boolean
  createdAt: AWSDateTime
}

input DeleteColonyHistoricRoleInput {
  id: ID!
}

input ModelSubscriptionColonyHistoricRoleFilterInput {
  id: ModelSubscriptionIDInput
  type: ModelSubscriptionStringInput
  domainId: ModelSubscriptionIDInput
  colonyId: ModelSubscriptionIDInput
  targetAddress: ModelSubscriptionIDInput
  blockNumber: ModelSubscriptionIntInput
  role_0: ModelSubscriptionBooleanInput
  role_1: ModelSubscriptionBooleanInput
  role_2: ModelSubscriptionBooleanInput
  role_3: ModelSubscriptionBooleanInput
  role_5: ModelSubscriptionBooleanInput
  role_6: ModelSubscriptionBooleanInput
  createdAt: ModelSubscriptionStringInput
  and: [ModelSubscriptionColonyHistoricRoleFilterInput]
  or: [ModelSubscriptionColonyHistoricRoleFilterInput]
}

type ModelIngestorStatsConnection {
  items: [IngestorStats]!
  nextToken: String
}

input ModelIngestorStatsFilterInput {
  id: ModelIDInput
  value: ModelStringInput
  and: [ModelIngestorStatsFilterInput]
  or: [ModelIngestorStatsFilterInput]
  not: ModelIngestorStatsFilterInput
}

input ModelIngestorStatsConditionInput {
  value: ModelStringInput
  and: [ModelIngestorStatsConditionInput]
  or: [ModelIngestorStatsConditionInput]
  not: ModelIngestorStatsConditionInput
}

input CreateIngestorStatsInput {
  id: ID
  value: String!
}

input UpdateIngestorStatsInput {
  id: ID!
  value: String
}

input DeleteIngestorStatsInput {
  id: ID!
}

input ModelSubscriptionIngestorStatsFilterInput {
  id: ModelSubscriptionIDInput
  value: ModelSubscriptionStringInput
  and: [ModelSubscriptionIngestorStatsFilterInput]
  or: [ModelSubscriptionIngestorStatsFilterInput]
}

input ExpenditureSlotInput {
  id: Int!
  recipientAddress: String
  claimDelay: Int
  payoutModifier: Int
  payouts: [ExpenditurePayoutInput!]
}

input ExpenditurePayoutInput {
  tokenAddress: ID!
  amount: String!
}

type ModelExpenditureConnection {
  items: [Expenditure]!
  nextToken: String
}

input ModelExpenditureStatusInput {
  eq: ExpenditureStatus
  ne: ExpenditureStatus
}

input ModelExpenditureFilterInput {
  id: ModelIDInput
  createdAt: ModelStringInput
  colonyId: ModelIDInput
  ownerAddress: ModelIDInput
  status: ModelExpenditureStatusInput
  and: [ModelExpenditureFilterInput]
  or: [ModelExpenditureFilterInput]
  not: ModelExpenditureFilterInput
  colonyExpendituresId: ModelIDInput
}

input ModelExpenditureConditionInput {
  createdAt: ModelStringInput
  colonyId: ModelIDInput
  ownerAddress: ModelIDInput
  status: ModelExpenditureStatusInput
  and: [ModelExpenditureConditionInput]
  or: [ModelExpenditureConditionInput]
  not: ModelExpenditureConditionInput
  colonyExpendituresId: ModelIDInput
}

input CreateExpenditureInput {
  id: ID
  createdAt: AWSDateTime
  colonyId: ID!
  ownerAddress: ID!
  status: ExpenditureStatus!
  slots: [ExpenditureSlotInput!]!
  colonyExpendituresId: ID
}

input UpdateExpenditureInput {
  id: ID!
  createdAt: AWSDateTime
  colonyId: ID
  ownerAddress: ID
  status: ExpenditureStatus
  slots: [ExpenditureSlotInput!]
  colonyExpendituresId: ID
}

input DeleteExpenditureInput {
  id: ID!
}

input ModelSubscriptionExpenditureFilterInput {
  id: ModelSubscriptionIDInput
  createdAt: ModelSubscriptionStringInput
  colonyId: ModelSubscriptionIDInput
  ownerAddress: ModelSubscriptionIDInput
  status: ModelSubscriptionStringInput
  and: [ModelSubscriptionExpenditureFilterInput]
  or: [ModelSubscriptionExpenditureFilterInput]
}

type ModelAnnotationConnection {
  items: [Annotation]!
  nextToken: String
}

input ModelAnnotationFilterInput {
  id: ModelIDInput
  actionId: ModelIDInput
  message: ModelStringInput
  ipfsHash: ModelStringInput
  and: [ModelAnnotationFilterInput]
  or: [ModelAnnotationFilterInput]
  not: ModelAnnotationFilterInput
}

input ModelAnnotationConditionInput {
  actionId: ModelIDInput
  message: ModelStringInput
  ipfsHash: ModelStringInput
  and: [ModelAnnotationConditionInput]
  or: [ModelAnnotationConditionInput]
  not: ModelAnnotationConditionInput
}

input CreateAnnotationInput {
  id: ID
  actionId: ID!
  message: String!
  ipfsHash: String
}

input UpdateAnnotationInput {
  id: ID!
  actionId: ID
  message: String
  ipfsHash: String
}

input DeleteAnnotationInput {
  id: ID!
}

input ModelSubscriptionAnnotationFilterInput {
  id: ModelSubscriptionIDInput
  actionId: ModelSubscriptionIDInput
  message: ModelSubscriptionStringInput
  ipfsHash: ModelSubscriptionStringInput
  and: [ModelSubscriptionAnnotationFilterInput]
  or: [ModelSubscriptionAnnotationFilterInput]
}

input SafeTransactionDataInput {
  transactionType: String!
  token: SafeBalanceTokenInput
  amount: String
  rawAmount: String
  recipient: SimpleTargetInput
  data: String
  contract: SimpleTargetInput
  abi: String
  contractFunction: String
  nft: NFTInput
  nftData: NFTDataInput
  functionParams: [FunctionParamInput]
}

input SafeBalanceTokenInput {
  name: String!
  decimals: Int!
  symbol: String!
  address: String!
  logoUri: String
}

input SimpleTargetInput {
  id: String!
  profile: SimpleTargetProfileInput!
  walletAddress: String!
}

input SimpleTargetProfileInput {
  avatarHash: String
  displayName: String
  username: String
}

input NFTInput {
  id: String!
  profile: NFTProfileInput!
  walletAddress: String!
}

input NFTProfileInput {
  displayName: String!
}

input NFTDataInput {
  address: String!
  description: String
  id: String!
  imageUri: String
  logoUri: String!
  name: String
  tokenName: String!
  tokenSymbol: String!
  uri: String!
}

input FunctionParamInput {
  name: String!
  type: String!
  value: String!
}

type ModelSafeTransactionConnection {
  items: [SafeTransaction]!
  nextToken: String
}

input ModelSafeTransactionFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  and: [ModelSafeTransactionFilterInput]
  or: [ModelSafeTransactionFilterInput]
  not: ModelSafeTransactionFilterInput
}

input ModelSafeTransactionConditionInput {
  title: ModelStringInput
  and: [ModelSafeTransactionConditionInput]
  or: [ModelSafeTransactionConditionInput]
  not: ModelSafeTransactionConditionInput
}

input CreateSafeTransactionInput {
  id: ID
  title: String!
  safe: SafeInput!
  transactions: [SafeTransactionDataInput!]!
}

input UpdateSafeTransactionInput {
  id: ID!
  title: String
  safe: SafeInput
  transactions: [SafeTransactionDataInput!]
}

input DeleteSafeTransactionInput {
  id: ID!
}

input ModelSubscriptionSafeTransactionFilterInput {
  id: ModelSubscriptionIDInput
  title: ModelSubscriptionStringInput
  and: [ModelSubscriptionSafeTransactionFilterInput]
  or: [ModelSubscriptionSafeTransactionFilterInput]
}

type ModelColonyTokensConnection {
  items: [ColonyTokens]!
  nextToken: String
}

input ModelColonyTokensFilterInput {
  id: ModelIDInput
  tokenID: ModelIDInput
  colonyID: ModelIDInput
  and: [ModelColonyTokensFilterInput]
  or: [ModelColonyTokensFilterInput]
  not: ModelColonyTokensFilterInput
}

input ModelColonyTokensConditionInput {
  tokenID: ModelIDInput
  colonyID: ModelIDInput
  and: [ModelColonyTokensConditionInput]
  or: [ModelColonyTokensConditionInput]
  not: ModelColonyTokensConditionInput
}

input CreateColonyTokensInput {
  id: ID
  tokenID: ID!
  colonyID: ID!
}

input UpdateColonyTokensInput {
  id: ID!
  tokenID: ID
  colonyID: ID
}

input DeleteColonyTokensInput {
  id: ID!
}

input ModelSubscriptionColonyTokensFilterInput {
  id: ModelSubscriptionIDInput
  tokenID: ModelSubscriptionIDInput
  colonyID: ModelSubscriptionIDInput
  and: [ModelSubscriptionColonyTokensFilterInput]
  or: [ModelSubscriptionColonyTokensFilterInput]
}

type ModelUserTokensConnection {
  items: [UserTokens]!
  nextToken: String
}

input ModelUserTokensFilterInput {
  id: ModelIDInput
  tokenID: ModelIDInput
  userID: ModelIDInput
  and: [ModelUserTokensFilterInput]
  or: [ModelUserTokensFilterInput]
  not: ModelUserTokensFilterInput
}

input ModelUserTokensConditionInput {
  tokenID: ModelIDInput
  userID: ModelIDInput
  and: [ModelUserTokensConditionInput]
  or: [ModelUserTokensConditionInput]
  not: ModelUserTokensConditionInput
}

input CreateUserTokensInput {
  id: ID
  tokenID: ID!
  userID: ID!
}

input UpdateUserTokensInput {
  id: ID!
  tokenID: ID
  userID: ID
}

input DeleteUserTokensInput {
  id: ID!
}

input ModelSubscriptionUserTokensFilterInput {
  id: ModelSubscriptionIDInput
  tokenID: ModelSubscriptionIDInput
  userID: ModelSubscriptionIDInput
  and: [ModelSubscriptionUserTokensFilterInput]
  or: [ModelSubscriptionUserTokensFilterInput]
}

type ModelWatchedColoniesConnection {
  items: [WatchedColonies]!
  nextToken: String
}

input ModelWatchedColoniesFilterInput {
  id: ModelIDInput
  colonyID: ModelIDInput
  userID: ModelIDInput
  and: [ModelWatchedColoniesFilterInput]
  or: [ModelWatchedColoniesFilterInput]
  not: ModelWatchedColoniesFilterInput
}

input ModelWatchedColoniesConditionInput {
  colonyID: ModelIDInput
  userID: ModelIDInput
  and: [ModelWatchedColoniesConditionInput]
  or: [ModelWatchedColoniesConditionInput]
  not: ModelWatchedColoniesConditionInput
}

input CreateWatchedColoniesInput {
  id: ID
  colonyID: ID!
  userID: ID!
}

input UpdateWatchedColoniesInput {
  id: ID!
  colonyID: ID
  userID: ID
}

input DeleteWatchedColoniesInput {
  id: ID!
}

input ModelSubscriptionWatchedColoniesFilterInput {
  id: ModelSubscriptionIDInput
  colonyID: ModelSubscriptionIDInput
  userID: ModelSubscriptionIDInput
  and: [ModelSubscriptionWatchedColoniesFilterInput]
  or: [ModelSubscriptionWatchedColoniesFilterInput]
}

input ModelStringKeyConditionInput {
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  between: [String]
  beginsWith: String
}

input ModelIDKeyConditionInput {
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  between: [ID]
  beginsWith: ID
}

"""
The AWSJSON scalar type represents a valid json object serialized as a string.
"""
scalar AWSJSON

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar AWSDate

"""
A time string at UTC, such as 10:15:30Z, compliant with the `full-time` format outlined in section 5.6 of the RFC 3339profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar AWSTime

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar AWSDateTime

"""AWSPhone"""
scalar AWSPhone

"""
A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.
"""
scalar AWSEmail

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar AWSURL

"""
The AWSTimestamp scalar type represents the number of seconds that have elapsed since 1970-01-01T00:00Z. Timestamps are serialized and deserialized as numbers. Negative values are also accepted and these represent the number of seconds till 1970-01-01T00:00Z.
"""
scalar AWSTimestamp

"""
The AWSIPAddress scalar type represents a valid IPv4 or IPv6 address string.
"""
scalar AWSIPAddress