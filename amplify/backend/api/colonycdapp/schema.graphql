# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

input TokenFromEverywhereArguments {
  tokenAddress: String!
}

input CreateUniqueUserInput {
  id: ID!
  name: String!
  profile: ProfileInput
}

input CreateUniqueColonyInput {
  id: ID!
  name: String!
  colonyNativeTokenId: ID!
  profile: ProfileInput
}

input ProfileInput {
  avatar: String
  thumbnail: String
  displayName: String
  bio: String
  location: String
  website: AWSURL
  email: AWSEmail
}

type TokenFromEverywhereReturn {
  items: [Token]
}

enum TokenType {
  COLONY
  ERC20
}

enum Networks {
  LOCAL
  MAINNET
  XDAI
}

type Query {
  getTokenFromEverywhere(
    input: TokenFromEverywhereArguments
  ): TokenFromEverywhereReturn @function(name: "fetchTokenFromChain")
}

type Mutation {
  createUniqueUser(
    input: CreateUniqueUserInput
  ): User @function(name: "createUniqueUser")
  createUniqueColony(
    input: CreateUniqueColonyInput
  ): User @function(name: "createUniqueColony")
}

# Applies to both Users and Colonies
# Might need to separate it into two later down the line
type Profile {
  avatar: String
  thumbnail: String
  displayName: String
  bio: String
  location: String
  website: AWSURL
  email: AWSEmail
}

type NativeTokenStatus {
  unlocked: Boolean
  mintable: Boolean
  unlockable: Boolean
}

type ColonyStatus {
  nativeToken: NativeTokenStatus
  recovery: Boolean
  deployed: Boolean
}

# Applies to both Colonies and Tokens
# It does not apply to user accounts as they can live on all networks
type Chain {
  network: Networks
  chainId: Int
}

type Token @model {
  id: ID! @index(name: "byAddress", queryField: "getTokenByAddress") # contract address
  name: String!
  symbol: String!
  decimals: Int!
  type: TokenType
    @index(name: "byType", queryField: "getTokensByType")
  colonies: [Colony] @manyToMany(relationName: "ColonyTokens")
  users: [User] @manyToMany(relationName: "UserTokens")
  chain: Chain
}

type Colony @model {
  id: ID! @index(name: "byAddress", queryField: "getColonyByAddress") # contract address
  name: String! @index(name: "byName", queryField: "getColonyByName")
  nativeToken: Token! @hasOne
  tokens: [Token] @manyToMany(relationName: "ColonyTokens")
  profile: Profile
  status: ColonyStatus
  chain: Chain
  watchers: [User] @manyToMany(relationName: "WatchedColonies") # colony subscriptions
}

type User @model {
  id: ID! @index(name: "byAddress", queryField: "getUserByAddress") # wallet address
  name: String! @index(name: "byName", queryField: "getUserByName")
  tokens: [Token] @manyToMany(relationName: "UserTokens")
  profile: Profile
  watchlist: [Colony] @manyToMany(relationName: "WatchedColonies") # colony subscriptions
}
