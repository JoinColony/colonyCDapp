# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY {
  globalAuthRule: AuthRule = { allow: public }
} # FOR TESTING ONLY!
# NOTE: This file is getting out hand in terms of size
# There is an official way of splitting the schema into multiple files
# https://docs.amplify.aws/cli-legacy/graphql-transformer/overview/#api-category-project-structure
# but I never could get it to work

"""
Input data for fetching a token's information from DB or chain
"""
input TokenFromEverywhereArguments {
  """
  Address of the token on the blockchain
  """
  tokenAddress: String!
  network: String
  """
  The URL of the token image
  """
  avatar: String
  """
  The URL of the token thumbnail image
  """
  thumbnail: String
}

"""
Input data for creating a unique user within the Colony Network Use this instead of the automatically generated `CreateUserInput` input type
"""
input CreateUniqueUserInput {
  """
  Unique identifier for the user. This is the user's wallet address
  """
  id: ID!
  """
  Profile data for the user
  """
  profile: ProfileInput!
}

"""
Input data for creating notifications data for a user
"""
input CreateUserNotificationsDataInput {
  """
  Unique identifier for the user. This is the user's wallet address
  """
  id: ID!
}

"""
Input data for a user's profile metadata
"""
input ProfileMetadataInput {
  """
  A flag to indicate whether the user has enabled metatransactions
  """
  metatransactionsEnabled: Boolean
  """
  A flag to indicate whether the user has enabled the decentralized mode
  """
  decentralizedModeEnabled: Boolean
  """
  The URL of the user's custom RPC node
  """
  customRpc: String
}

"""
Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later
"""
input NativeTokenStatusInput {
  """
  Whether the native token is unlocked
  """
  unlocked: Boolean
  """
  Whether the native token is mintable
  """
  mintable: Boolean
  """
  Whether the native token can be unlocked
  """
  unlockable: Boolean
}

"""
Input data for a Colony's status information

This is set when a Colony is created and can be changed later
"""
input ColonyStatusInput {
  """
  Status information for the Colony's native token
  """
  nativeToken: NativeTokenStatusInput
  """
  Whether the Colony is in recovery mode
  """
  recovery: Boolean
}

"""
Input data for creating a temporary colony metadata entry
"""
input CreateColonyEtherealMetadataInput {
  """
  User id of creator to associate with further invite codes
  """
  initiatorAddress: ID!
  """
  The transaction hash of colony creation transaction
  """
  transactionHash: String!
  """
  Invite Code to create Colony
  """
  inviteCode: ID!
  """
  Colony slug
  """
  colonyName: String!
  """
  Colony name
  """
  colonyDisplayName: String!
  """
  Colony avatar/thumbnail
  """
  colonyAvatar: String
  """
  Colony avatar/thumbnail
  """
  colonyThumbnail: String
  """
  Token avatar/thumbnail
  """
  tokenAvatar: String
  """
  Token avatar/thumbnail
  """
  tokenThumbnail: String
}

"""
Input data to use when creating or changing a user profile
"""
input ProfileInput {
  """
  The unique identifier for the user profile
  """
  id: ID
  """
  The URL of the user's avatar image
  """
  avatar: String
  """
  The URL of the user's thumbnail image
  """
  thumbnail: String
  """
  The display name of the user
  """
  displayName: String
  """
  A short description or biography of the user.
  """
  bio: String
  """
  The user's location (e.g., city or country)
  """
  location: String
  """
  The user's personal or professional website
  """
  website: AWSURL
  """
  The user's email address
  """
  email: AWSEmail
  """
  Any additional metadata or settings related to the user profile
  """
  meta: ProfileMetadataInput
}

"""
Input data for a user's reputation within a Domain in a Colony. If no `domainId` is passed, the Root Domain is used
A `rootHash` can be provided, to get reputation at a certain point in the past
"""
input GetUserReputationInput {
  """
  The Ethereum wallet address of the user
  """
  walletAddress: String!
  """
  The Ethereum address of the Colony
  """
  colonyAddress: String!
  """
  The ID of the Domain within the Colony. If not provided, defaults to the Root Domain
  """
  domainId: Int
  """
  The root hash of the reputation tree at a specific point in time
  """
  rootHash: String
}

input UpdateContributorsWithReputationInput {
  """
  The colony address
  """
  colonyAddress: String # allow undefined
}

"""
Input data for updating an extension's information within a Colony, based on the Colony ID and extension hash
The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
"""
input UpdateExtensionByColonyAndHashInput {
  """
  The unique identifier for the Colony
  """
  colonyId: ID!
  """
  The hash of the extension to be updated
  """
  hash: String!
  """
  A flag to indicate whether the extension is deprecated
  """
  isDeprecated: Boolean
  """
  A flag to indicate whether the extension is deleted
  """
  isDeleted: Boolean
  """
  A flag to indicate whether the extension is initialized
  """
  isInitialized: Boolean
  """
  The version of the extension
  """
  version: Int
  """
  The Ethereum address of the user who installed the extension
  """
  installedBy: String
  """
  The timestamp when the extension was installed
  """
  installedAt: AWSTimestamp
}

input GetSafeTransactionStatusInput {
  transactionHash: String!
  chainId: String!
}

input BridgeXYZMutationAddressInput {
  street_line_1: String!
  street_line_2: String
  city: String!
  state: String
  postal_code: String
  country: String!
}

input BridgeXYZMutationIbanInput {
  account_number: String!
  bic: String!
  country: String!
}

input BridgeXYZMutationAccountInput {
  account_number: String!
  routing_number: String!
}

input BridgeXYZMutationBodyInput {
  #
  # KYC Links
  #
  full_name: String
  email: String

  #
  # Put Customer
  #
  first_name: String
  last_name: String
  address: BridgeXYZMutationAddressInput
  birth_date: String
  tax_identification_number: String
  signed_agreement_id: String
  currency: String
  bank_name: String
  iban: BridgeXYZMutationIbanInput
  account: BridgeXYZMutationAccountInput
}

input BridgeXYZMutationInput {
  path: String!
  body: BridgeXYZMutationBodyInput!
}

input BridgeUsAccountInput {
  account_number: String!
  routing_number: String!
}

input BridgeIbanAccountInput {
  account_number: String!
  bic: String!
  country: String!
}

input BridgeCreateBankAccountInput {
  iban: BridgeIbanAccountInput
  usAccount: BridgeUsAccountInput
  currency: String!
  bankName: String!
  address: BridgeXYZMutationAddressInput
  accountOwner: String!
}

input BridgeUpdateBankAccountInput {
  id: String!
  account: BridgeCreateBankAccountInput!
}

type BridgeCreateBankAccountReturn {
  success: Boolean
}

type BridgeUpdateBankAccountReturn {
  success: Boolean
}

type BridgeXYZMutationReturn {
  #
  # KYC Links
  #
  tos_link: String
  kyc_link: String

  success: Boolean
}

"""
Return type for tokens gotten from DB or from chain
"""
type TokenFromEverywhereReturn {
  """
  List of tokens found
  """
  items: [Token]
}

"""
Input data for retrieving a user's token balance for a specific token
"""
input GetUserTokenBalanceInput {
  """
  The wallet address of the user
  """
  walletAddress: String!
  """
  The Colony address
  """
  colonyAddress: String!
  """
  The address of the token
  """
  tokenAddress: String!
}

"""
Input data for retrieving the state of a motion (i.e. the current period)
"""
input GetMotionStateInput {
  """
  The Ethereum address of the Colony
  """
  colonyAddress: String!
  """
  The internal id of the motion in the database
  """
  databaseMotionId: String!
}

"""
Input data for retrieving the voting rewards for a user within a finished motion
"""
input GetVoterRewardsInput {
  """
  The Ethereum address of the user who voted
  """
  voterAddress: String!
  """
  The Ethereum address of the Colony
  """
  colonyAddress: String!
  """
  The on chain id of the domain in which the motion was created
  """
  nativeMotionDomainId: String!
  """
  The on chain id of the motion
  """
  motionId: String!
  """
  The root hash of the reputation tree at the time the motion was created
  """
  rootHash: String!
}

"""
Input data for retrieving the timeout of the current period the motion is in
"""
input GetMotionTimeoutPeriodsInput {
  """
  The on chain id of the motion
  """
  motionId: String!
  """
  The Ethereum address of the user who voted
  """
  colonyAddress: String!
}

"""
A return type representing the breakdown of a user's token balance
"""
type GetUserTokenBalanceReturn {
  """
  The total token balance, including inactive, locked, and active balances
  """
  balance: String
  """
  The inactive portion of the user's token balance
  This is the balance of a token that is in a users wallet but can't be used by the Colony Network (e.g. for governance)
  """
  inactiveBalance: String
  """
  The locked portion of the user's token balance
  This is the balance of a token that is staked (e.g. in motions)
  """
  lockedBalance: String
  """
  The active portion of the user's token balance
  This is the balance that is approved for the Colony Network to use (e.g. for governance)
  """
  activeBalance: String
  """
  The pending portion of the user's token balance
  These are tokens that have been sent to the wallet, but are inaccessible until all locks are cleared and then these tokens are claimed
  """
  pendingBalance: String
}

"""
A return type that contains the timeout periods the motion can be in
Represented via a string-integer in milliseconds. Will report 0 for periods that are elapsed and will show the accumulated time for later periods
"""
type GetMotionTimeoutPeriodsReturn {
  """
  Time left in staking period
  """
  timeLeftToStake: String!
  """
  Time left in voting period
  """
  timeLeftToVote: String!
  """
  Time left in reveal period
  """
  timeLeftToReveal: String!
  """
  Time left in escalation period
  """
  timeLeftToEscalate: String!
}

"""
A return type that contains the voting reward for a user and a motion
`min` and `max` specify the potential reward range when the actual reward is unknown (before the _reveal_ phase)
"""
type VoterRewardsReturn {
  """
  The minimum possible reward amount
  Only useful before the _reveal_ phase, when the actual amount is known
  """
  min: String!
  """
  The maximum possible reward amount
  Only useful before the _reveal_ phase, when the actual amount is known
  """
  max: String!
  """
  The actual reward amount
  """
  reward: String!
}

"""
Variants of different token types a Colony can use
As Colonies can use multiple tokens and even own tokens (BYOT), we need to differentiate
"""
enum TokenType {
  """
  A (ERC20-compatible) token that was deployed with Colony. It has a few more features, like minting through the Colony itself
  """
  COLONY
  """
  An ERC20-compatible token
  """
  ERC20
  """
  The native token of the Chain used (e.g. ETH on mainnet or xDAI on Gnosis-Chain)
  """
  CHAIN_NATIVE
}

"""
Variants of supported Ethereum networks
"""
enum Network {
  """
  Local development network using Ganache
  """
  GANACHE
  """
  Ethereum Mainnet
  """
  MAINNET
  """
  Ethereum Goerli test network
  """
  GOERLI
  """
  Gnosis Chain network
  """
  GNOSIS
  """
  Fork of Gnosis Chain for QA purposes
  """
  GNOSISFORK
}

"""
Variants of available domain colors as used in the dApp
"""
enum DomainColor {
  """
  The default domain color for the root domain. Only used by the root by default and cannot be selected by the user.
  """
  ROOT
  """
  A light pink color
  """
  LIGHT_PINK
  """
  A pink color
  """
  PINK
  """
  A black color
  """
  BLACK
  """
  An emerald green color
  """
  EMERALD_GREEN
  """
  A blue color
  """
  BLUE
  """
  A yellow color
  """
  YELLOW
  """
  A red color
  """
  RED
  """
  A green color
  """
  GREEN
  """
  A pale indigo color
  """
  PERIWINKLE
  """
  A gold color
  """
  GOLD
  """
  An aqua color
  """
  AQUA
  """
  A blue-grey(ish) color
  """
  BLUE_GREY
  """
  A purple color
  """
  PURPLE
  """
  An orange color
  """
  ORANGE
  """
  A magenta color
  """
  MAGENTA
  """
  A purple-grey(ish) color
  """
  PURPLE_GREY
}

"""
Variants of Colony types
"""
enum ColonyType {
  """
  A regular Colony
  """
  COLONY
  """
  The MetaColony, which governs the entire Colony Network
  """
  METACOLONY
}

"""
Variants of Colony Network blockchain events

These can all happen in a Colony and will be interpreted by the dApp according to their types
"""
enum ColonyActionType {
  """
  A generic or unspecified Colony action
  """
  GENERIC
  """
  An motion action placeholder that should not be used
  """
  NULL_MOTION
  """
  An action unrelated to the currently viewed Colony
  """
  WRONG_COLONY
  """
  An action related to a payment within a Colony
  """
  PAYMENT
  """
  An action related to making multiple payments within a Colony
  """
  MULTIPLE_PAYMENT
  """
  An action related to a payment that was created via a motion within a Colony
  """
  PAYMENT_MOTION
  """
  An action related to a payment that was created via multiSig within a Colony
  """
  PAYMENT_MULTISIG
  """
  An action related to making multiple payments within a Colony
  """
  MULTIPLE_PAYMENT_MOTION
  """
  A multiSig action related to making multiple payments within a Colony
  """
  MULTIPLE_PAYMENT_MULTISIG
  """
  An action related to the recovery functionality of a Colony
  """
  RECOVERY
  """
  An action related to moving funds between domains
  """
  MOVE_FUNDS
  """
  An action related to moving funds between domains via a motion
  """
  MOVE_FUNDS_MOTION
  """
  An action related to moving funds between domains via multiSig
  """
  MOVE_FUNDS_MULTISIG
  """
  An action related to unlocking a token within a Colony
  """
  UNLOCK_TOKEN
  """
  An action related to unlocking a token within a Colony via a motion
  """
  UNLOCK_TOKEN_MOTION
  """
  An action related to unlocking a token within a Colony via multiSig
  """
  UNLOCK_TOKEN_MULTISIG
  """
  An action related to minting tokens within a Colony
  """
  MINT_TOKENS
  """
  An action related to minting tokens within a Colony via a motion
  """
  MINT_TOKENS_MOTION
  """
  An action related to minting tokens within a Colony via multiSig
  """
  MINT_TOKENS_MULTISIG
  """
  An action related to creating a domain within a Colony
  """
  CREATE_DOMAIN
  """
  An action related to creating a domain within a Colony via a motion
  """
  CREATE_DOMAIN_MOTION
  """
  An action related to creating a domain within a Colony via multiSig
  """
  CREATE_DOMAIN_MULTISIG
  """
  An action related to upgrading a Colony's version
  """
  VERSION_UPGRADE
  """
  An action related to upgrading a Colony's version via a motion
  """
  VERSION_UPGRADE_MOTION
  """
  An action related to upgrading a Colony's version via multiSig
  """
  VERSION_UPGRADE_MULTISIG
  """
  An action related to editing a Colony's details
  """
  COLONY_EDIT
  """
  An action related to editing a Colony's details via a motion
  """
  COLONY_EDIT_MOTION
  """
  An action related to editing a Colony's details via multiSig
  """
  COLONY_EDIT_MULTISIG
  """
  An action related to editing a domain's details
  """
  EDIT_DOMAIN
  """
  An action related to editing a domain's details via a motion
  """
  EDIT_DOMAIN_MOTION
  """
  An action related to editing a domain's details via multiSig
  """
  EDIT_DOMAIN_MULTISIG
  """
  An action related to setting user roles within a Colony
  """
  SET_USER_ROLES
  """
  An action related to setting user roles within a Colony via a motion
  """
  SET_USER_ROLES_MOTION
  """
  An action related to setting user roles within a Colony via multiSig
  """
  SET_USER_ROLES_MULTISIG
  """
  An action related to a domain reputation penalty within a Colony (smite)
  """
  EMIT_DOMAIN_REPUTATION_PENALTY
  """
  An action related to a domain reputation penalty within a Colony (smite) via a motion
  """
  EMIT_DOMAIN_REPUTATION_PENALTY_MOTION
  """
  An action related to a domain reputation penalty within a Colony (smite) via multiSig
  """
  EMIT_DOMAIN_REPUTATION_PENALTY_MULTISIG
  """
  An action related to a domain reputation reward within a Colony
  """
  EMIT_DOMAIN_REPUTATION_REWARD
  """
  An action related to a domain reputation reward within a Colony via a motion
  """
  EMIT_DOMAIN_REPUTATION_REWARD_MOTION
  """
  An action related to a domain reputation reward within a Colony via multiSig
  """
  EMIT_DOMAIN_REPUTATION_REWARD_MULTISIG
  """
  An action related to a creating a Decision within a Colony via a motion
  """
  CREATE_DECISION_MOTION
  """
  An action related to a creating a Decision within a Colony via multiSig
  """
  CREATE_DECISION_MULTISIG
  """
  An action related to creating a motion for funding an expenditure
  """
  FUND_EXPENDITURE_MOTION
  """
  An action related to creating a multiSig for funding an expenditure
  """
  FUND_EXPENDITURE_MULTISIG
  """
  An action related to canceling an expenditure
  """
  CANCEL_EXPENDITURE
  """
  An action related to a motion to cancel an expenditure
  """
  CANCEL_EXPENDITURE_MOTION
  """
  An action related to a multiSig to cancel a staked expenditure
  """
  CANCEL_STAKED_EXPENDITURE_MULTISIG
  """
  An action related to creating a motion to release an expenditure stage
  """
  SET_EXPENDITURE_STATE_MOTION
  """
  An action related to creating a multiSig to release an expenditure stage
  """
  SET_EXPENDITURE_STATE_MULTISIG
  """
  An action related to editing an expenditure
  """
  EDIT_EXPENDITURE
  """
  An action related to creating a motion to edit an expenditure
  """
  EDIT_EXPENDITURE_MOTION
  """
  An action related to a motion to release a staged payment
  """
  RELEASE_STAGED_PAYMENTS
  """
  An action related to a motion to release a staged payment
  """
  RELEASE_STAGED_PAYMENTS_MOTION
  """
  An action related to the creation of safe transactions via Safe Control
  """
  MAKE_ARBITRARY_TRANSACTION
  MAKE_ARBITRARY_TRANSACTIONS_MOTION
  MAKE_ARBITRARY_TRANSACTIONS_MULTISIG
  """
  An action related to adding verified members
  """
  ADD_VERIFIED_MEMBERS
  ADD_VERIFIED_MEMBERS_MOTION
  ADD_VERIFIED_MEMBERS_MULTISIG
  """
  An action related to removing verified members
  """
  REMOVE_VERIFIED_MEMBERS
  REMOVE_VERIFIED_MEMBERS_MOTION
  REMOVE_VERIFIED_MEMBERS_MULTISIG
  """
  An action related to creating an expenditure (advanced payment)
  """
  CREATE_EXPENDITURE
  """
  An action related to locking an expenditure
  """
  LOCK_EXPENDITURE
  """
  An action related to finalizing an expenditure
  """
  FINALIZE_EXPENDITURE
  """
  An action related to finalizing an expenditure via a motion
  """
  FINALIZE_EXPENDITURE_MOTION
  """
  An action related to adding / removing approved colony tokens
  """
  MANAGE_TOKENS
  MANAGE_TOKENS_MOTION
  MANAGE_TOKENS_MULTISIG
  """
  An action related to arbitrary transaction
  """
  ARBITRARY_TX
}

"""
Variants of sorting methods for a member list
"""
enum SortingMethod {
  """
  Sort members by highest reputation
  """
  BY_HIGHEST_REP
  """
  Sort members by lowest reputation
  """
  BY_LOWEST_REP
  """
  Sort members by having more permissions
  """
  BY_MORE_PERMISSIONS
  """
  Sort members by having fewer permissions
  """
  BY_LESS_PERMISSIONS
}

enum FilteringMethod {
  """
  Apply a union filter
  """
  UNION

  """
  Apply an intersection filter
  """
  INTERSECTION
}

enum ExpenditureStatus {
  DRAFT
  LOCKED
  FINALIZED
  CANCELLED
}

enum ExpenditureType {
  PAYMENT_BUILDER
  STAGED
}

enum StreamingPaymentEndCondition {
  WHEN_CANCELLED
  LIMIT_REACHED
  FIXED_TIME
}

enum SplitPaymentDistributionType {
  EQUAL
  UNEQUAL
  REPUTATION
}

"""
The types of contributor a user can be in a colony
"""
enum ContributorType {
  TOP
  DEDICATED
  ACTIVE
  NEW
  GENERAL
}

"""
Type of stake a user can make
"""
enum UserStakeType {
  MOTION
  STAKED_EXPENDITURE
}

"""
Type of notifications that can be sent
"""
enum NotificationType {
  # Expenditures
  EXPENDITURE_READY_FOR_REVIEW
  EXPENDITURE_READY_FOR_FUNDING
  EXPENDITURE_READY_FOR_RELEASE
  EXPENDITURE_FINALIZED
  EXPENDITURE_PAYOUT_CLAIMED
  EXPENDITURE_CANCELLED

  # Extensions
  EXTENSION_INSTALLED
  EXTENSION_UPGRADED
  EXTENSION_ENABLED
  EXTENSION_DEPRECATED
  EXTENSION_UNINSTALLED
  EXTENSION_SETTINGS_CHANGED

  # Funds
  FUNDS_CLAIMED

  # Mentions
  MENTION

  # Motions
  MOTION_CREATED
  MOTION_SUPPORTED
  MOTION_OPPOSED
  MOTION_VOTING
  MOTION_REVEAL
  MOTION_FINALIZED

  # Multisig
  MULTISIG_ACTION_CREATED
  MULTISIG_ACTION_FINALIZED
  MULTISIG_ACTION_APPROVED
  MULTISIG_ACTION_REJECTED

  # Actions made with permissions
  PERMISSIONS_ACTION
  # versions
  NEW_COLONY_VERSION
  NEW_EXTENSION_VERSION
}

"""
Root query type
"""
type Query {
  """
  Fetch a token's information. Tries to get the data from the DB first, if that fails, resolves to get data from chain
  """
  getTokenFromEverywhere(
    input: TokenFromEverywhereArguments
  ): TokenFromEverywhereReturn @function(name: "fetchTokenFromChain-${env}")

  """
  Retrieve a user's reputation within a specific domain in a Colony
  """
  getUserReputation(input: GetUserReputationInput): String
    @function(name: "getUserReputation-${env}")

  """
  Retrieve a user's token balance for a specific token
  """
  getUserTokenBalance(
    input: GetUserTokenBalanceInput
  ): GetUserTokenBalanceReturn @function(name: "getUserTokenBalance-${env}")

  """
  Get the state of a motion (i.e. the current period)
  """
  getMotionState(input: GetMotionStateInput): Int!
    @function(name: "fetchMotionState-${env}")

  """
  Get the voting reward for a user and a motion
  """
  getVoterRewards(input: GetVoterRewardsInput): VoterRewardsReturn
    @function(name: "fetchVoterRewards-${env}")

  """
  Get the timeout for the current period of a motion
  """
  getMotionTimeoutPeriods(
    input: GetMotionTimeoutPeriodsInput
  ): GetMotionTimeoutPeriodsReturn
    @function(name: "fetchMotionTimeoutPeriods-${env}")

  getSafeTransactionStatus(input: GetSafeTransactionStatusInput): [String!]
    @function(name: "getSafeTransactionStatus-${env}")

  """
  Get drains history for the current user
  """
  bridgeGetDrainsHistory: [BridgeDrain!]
    @function(name: "bridgeXYZMutation-${env}")

  """
  Check bridge KYC status for the current user
  """
  bridgeCheckKYC: BridgeCheckKYCReturn
    @function(name: "bridgeXYZMutation-${env}")

  """
  Get liquidation address of a given user
  """
  bridgeGetUserLiquidationAddress(userAddress: String!): String
    @function(name: "bridgeXYZMutation-${env}")
  """
  Get bridge gateway fee
  """
  bridgeGetGatewayFee: BridgeGatewayFeeReturn
    @function(name: "bridgeXYZMutation-${env}")

  """
  Fetch a domain total balance
  """
  getDomainBalance(input: DomainBalanceArguments!): DomainBalanceReturn
    @function(name: "fetchDomainBalance-${env}")

  """
  Trigger the balance caching
  """
  cacheAllDomainBalance: CacheAllDomainBalanceReturn
    @function(name: "cacheDomainBalance-${env}")

  """
  Generate key for the user in Magicbell, used for secure fetching of notifications
  """
  getUserNotificationsHMAC: String
    @function(name: "getUserNotificationsHMAC-${env}")
}

"""
Root mutation type
"""
type Mutation {
  """
  Create a unique user within the Colony Network. Use this instead of the automatically generated `createUser` mutation
  """
  createUniqueUser(input: CreateUniqueUserInput): User
    @function(name: "createUniqueUser-${env}")

  """
  Create notification data for a user
  """
  createUserNotificationsData(
    input: CreateUserNotificationsDataInput!
  ): NotificationsData @function(name: "createUserNotificationsData-${env}")

  """
  Create temporary metadata entry for an upcoming colony (that will be created by the ingestor)
  """
  createColonyEtherealMetadata(
    input: CreateColonyEtherealMetadataInput!
  ): ColonyMetadata @function(name: "createColonyEtherealMetadata-${env}")

  """
  Update contributors with reputation in the database for a colony
  """
  updateContributorsWithReputation(
    input: UpdateContributorsWithReputationInput!
  ): Boolean @function(name: "updateContributorsWithReputation-${env}")
  """
  Validates the user invite code and adds the user as a colony contributor
  """
  validateUserInvite(input: ValidateUserInviteInput!): Boolean
    @function(name: "validateUserInvite-${env}")
  """
  Initialize user (for now only cancels pending transactions)
  """
  initializeUser(input: InitializeUserInput!): InitializeUserReturn!
    @function(name: "initializeUser-${env}")
  """
  Post to the Bridge XYZ API
  """
  bridgeXYZMutation(input: BridgeXYZMutationInput!): BridgeXYZMutationReturn
    @function(name: "bridgeXYZMutation-${env}")
  """
  Create a Bridge XYZ Bank Account
  """
  bridgeCreateBankAccount(
    input: BridgeCreateBankAccountInput!
  ): BridgeCreateBankAccountReturn @function(name: "bridgeXYZMutation-${env}")
  """
  Update a Bridge XYZ Bank Account
  """
  bridgeUpdateBankAccount(
    input: BridgeUpdateBankAccountInput!
  ): BridgeUpdateBankAccountReturn @function(name: "bridgeXYZMutation-${env}")
}

"""
Represents the currencies/tokens that users' balances can be converted to (for display purposes)
"""
enum SupportedCurrencies {
  USD # US Dollar
  JPY # Japanese Yen
  GBP # British Pound Sterling
  EUR # Euro
  CAD # Canadian Dollar
  KRW # South Korean Won
  INR # Indian Rupee
  BRL # Brazilian Real
  ETH # Ethereum
  CLNY # Colony Network Token
}

enum ExtendedSupportedCurrencies {
  USD # US Dollar
  JPY # Japanese Yen
  GBP # British Pound Sterling
  EUR # Euro
  CAD # Canadian Dollar
  KRW # South Korean Won
  INR # Indian Rupee
  BRL # Brazilian Real
  ETH # Ethereum
  CLNY # Colony Network Token
  USDC
}

"""
Represents a user's profile within the Colony Network
"""
type Profile @model {
  """
  Unique identifier for the user's profile
  """
  id: ID!
  """
  URL of the user's avatar image
  """
  avatar: String
  """
  URL of the user's thumbnail image
  """
  thumbnail: String
  """
  Display name of the user
  """
  displayName: String
    @index(name: "byDisplayName", queryField: "getProfileByUsername")
  """
  Date displayName was changed
  """
  displayNameChanged: AWSDateTime
  """
  User's bio information
  """
  bio: String
  """
  User's location information
  """
  location: String
  """
  URL of the user's website
  """
  website: AWSURL
  """
  User's email address
  """
  email: AWSEmail @index(name: "byEmail", queryField: "getProfileByEmail")
  """
  Metadata associated with the user's profile
  """
  meta: ProfileMetadata

  """
  The user associated with this profile
  """
  user: User! @belongsTo(fields: ["id"])

  """
  A user's prefered currency, for conversion purposes
  """
  preferredCurrency: SupportedCurrencies
  """
  Is automatic offramp enabled
  """
  isAutoOfframpEnabled: Boolean
  """
  Whether the user has completed the Persona KYC Flow
  Note: This doesn't indicate the outcome of the KYC check
  """
  hasCompletedKYCFlow: Boolean
}

"""
Represents the status of a Colony's native token
Colonies can have different types of native tokens in various modes. Here we define some important properties that the dApp uses to enable or disable certain features or views. This is set when a Colony is created and can be changed later
"""
type NativeTokenStatus {
  """
  Whether the native token is unlocked
  """
  unlocked: Boolean
  """
  Whether the user has permissions to mint new tokens
  """
  mintable: Boolean
  """
  Whether the native token can be unlocked
  """
  unlockable: Boolean
}

"""
Represents the status of a Colony

This contains important meta information about the Colony's token and other fundamental settings
"""
type ColonyStatus {
  """
  Status information for the Colony's native token
  """
  nativeToken: NativeTokenStatus
  """
  Whether the Colony is in recovery mode
  """
  recovery: Boolean
}

"""
Represents metadata related to a blockchain event
Applies to Colonies, Tokens and Events, but not all fields are revlant to all
It does not apply to user accounts as they can live on all networks
"""
type ChainMetadata {
  """
  The network the event occurred on
  """
  network: Network
  """
  The chain ID of the event
  """
  chainId: String!
  """
  The transaction hash of the event
  """
  transactionHash: String
  """
  The log index of the event
  """
  logIndex: Int
  """
  The block number of the event
  """
  blockNumber: Int
}

"""
Represents metadata for a user's profile. Mostly user specific settings
"""
type ProfileMetadata {
  """
  A flag to indicate whether the user has enabled metatransactions
  """
  metatransactionsEnabled: Boolean
  """
  A flag to indicate whether the user has enabled the decentralized mode
  """
  decentralizedModeEnabled: Boolean
  """
  The URL of the user's custom RPC node
  """
  customRpc: String
}

"""
Represents an ERC20-compatible token that is used by Colonies and users
"""
type Token @model {
  """
  Unique identifier for the token (contract address)
  """
  id: ID!
    @index(name: "byAddress", queryField: "getTokenByAddress")
    @index(sortKeyFields: ["createdAt"]) # contract address
  """
  Name of the token
  """
  name: String!
  """
  Symbol of the token
  """
  symbol: String!
  """
  Decimal precision of the token
  """
  decimals: Int!
  """
  Type of the token. See `TokenType` for more information
  """
  type: TokenType @index(name: "byType", queryField: "getTokensByType")
  """
  List of colonies using the token
  """
  colonies: [Colony] @manyToMany(relationName: "ColonyTokens")
  """
  List of users using the token
  """
  users: [User] @manyToMany(relationName: "UserTokens")
  """
  URL of the token's avatar image (logo)
  """
  avatar: String
  """
  URL of the token's thumbnail image (Small logo)
  """
  thumbnail: String
  """
  Metadata related to the chain of the token
  """
  chainMetadata: ChainMetadata!
  """
  Timestamp of the token model's creation in the database
  """
  createdAt: AWSDateTime!
  """
  If the token was validated by the Colony Team, meaning it shows up in the manage tokens list to add to your colony
  """
  validated: Boolean
}

type ContributorReputation @model {
  """
  Unique identifier
  Format: `<colonyAddress>_<domainNativeId>_<contributorAddress>`
  """
  id: ID!
  """
  The address of the contributor
  """
  contributorAddress: ID!
    @index(
      name: "byContributorAddress"
      queryField: "getUserReputationInColony"
      sortKeyFields: ["colonyAddress"]
    )

  """
  The colony the reputation was earned in
  """
  colonyAddress: ID!

  """
  The domain id in which the contributor has reputation
  """
  domainId: ID!

  """
  The associated Domain model
  """
  domain: Domain! @hasOne(fields: ["domainId"])

  """
  The raw value of the contributor's reputation in the domain
  """
  reputationRaw: String!

  """
  The percentage of the contributor's reputation in the domain
  """
  reputationPercentage: Float!
}

"""
The ColonyContributor model represents a contributor to the Colony.
"""
type ColonyContributor @model @searchable {
  """
  Unique identifier
  Format: <colonyAddress>_<contributorAddress>
  """
  id: ID!

  """
  The address of the contributor
  """
  contributorAddress: ID!
    @index(
      name: "byAddress"
      queryField: "getContributorsByAddress"
      sortKeyFields: ["colonyReputationPercentage"]
    )

  """
  The type of the contributor
  """
  type: ContributorType

  """
  Is the contributor a verified member of the colony?
  """
  isVerified: Boolean!

  """
  Is the contributor watching the colony
  """
  isWatching: Boolean

  """
  Does the contributor have any permission in any domain the colony?
  """
  hasPermissions: Boolean

  """
  Does the contributor have any reputation the colony?
  """
  hasReputation: Boolean

  """
  The contributor's reputation in the domains in which they have reputation
  """
  reputation: [ContributorReputation!]
    @hasMany(indexName: "byContributorAddress", fields: ["contributorAddress"])

  """
  The contributor's reputation percentage in the colony
  """
  colonyReputationPercentage: Float!
  """
  Associated user, if any
  """
  user: User @hasOne(fields: ["contributorAddress"])

  """
  Address of the colony the contributor is under
  """
  colonyAddress: ID!
    @index(
      name: "byColonyAddress"
      queryField: "getContributorsByColony"
      sortKeyFields: ["colonyReputationPercentage"]
    )

  """
  Associated colony
  """
  colony: Colony! @hasOne(fields: ["colonyAddress"])

  """
  A list of roles associated with the contributor
  """
  roles: [ColonyRole]
    @hasMany(indexName: "byTargetAddress", fields: ["contributorAddress"])
}

"""
Represents a Colony within the Colony Network
"""
type Colony @model {
  """
  Unique identifier for the Colony (contract address)
  """
  id: ID! @index(name: "byAddress", queryField: "getColonyByAddress")
  """
  (Short) name of the Colony
  """
  name: String! @index(name: "byName", queryField: "getColonyByName")
  """
  The unique address of the native token of the Colony
  """
  nativeTokenId: ID!
    @index(name: "byNativeTokenId", queryField: "getColoniesByNativeTokenId")
  """
  The native token of the Colony
  """
  nativeToken: Token! @hasOne(fields: ["nativeTokenId"])
  """
  List of tokens that are used within the Colony
  """
  tokens: [Token] @manyToMany(relationName: "ColonyTokens")
  """
  Status information for the Colony
  """
  status: ColonyStatus
  """
  List of domains of the Colony
  """
  domains: [Domain] @hasMany(indexName: "byColony", fields: ["id"])
  """
  List of Colony funds claims for all ERC20 tokens
  """
  # NOTE: Could not merge these two fields properly
  # Ideally we would merge data from these two into one field, but I couldn't do that
  # meaning we'll have to merge this data in-app (or not at all, works either way)
  # If you have a better idea, on how to merged them, I'll all ears..
  fundsClaimData: [ColonyFundsClaim]
    @hasMany(indexName: "byColony", fields: ["id"])
  """
  Native chain token claim (e.g., Token 0x0000...0000: ETH, xDAI, etc.)
  This is not an array since only a single token type can be returned
  """
  chainFundsClaim: ColonyChainFundsClaim
    @function(name: "fetchColonyNativeFundsClaim-${env}")
  """
  Type of the Colony (Regular or Metacolony)
  """
  type: ColonyType @index(name: "byType", queryField: "getColonyByType")
  """
  Returns a list token balances for each domain and each token that the colony has
  """
  balances: ColonyBalances @function(name: "fetchColonyBalances-${env}")
  """
  Metadata related to the chain of the Colony
  """
  chainMetadata: ChainMetadata!
  """
  List of extensions installed in the Colony
  """
  extensions: [ColonyExtension!] @hasMany(indexName: "byColony", fields: ["id"])
  """
  Version of the Colony
  """
  version: Int!
  """
  List of actions that happened within the Colony
  """
  actions: [ColonyAction] @hasMany
  """
  List of motions within the Colony that have unclaimed stakes
  """
  motionsWithUnclaimedStakes: [ColonyUnclaimedStake!]
  """
  Metadata of the Colony
  """
  metadata: ColonyMetadata @hasOne(fields: ["id"])
  """
  List of all roles within the Colony
  """
  # @TODO This should not be fetched upfront
  # It should be retrieved on demand at the earliest occasion it's needed
  # ie: when opening a UAC modal
  roles: [ColonyRole] @hasMany

  """
  Time at which the contributors with reputation in the colony were last updated
  """
  lastUpdatedContributorsWithReputation: AWSDateTime

  """
  The total reputation amount in the colony
  """
  reputation: String

  expenditures: [Expenditure] @hasMany(indexName: "byColony", fields: ["id"])
  """
  Global claim delay for expenditures (in seconds)
  """
  expendituresGlobalClaimDelay: String

  """
  A flag to indicate whether the colony is private
  """
  private: Boolean @default(value: "true")

  """
  ID of the main member invite object
  """
  colonyMemberInviteCode: ID
  """
  The main member invite object
  It is possible to create multiple member invites for a given colony
  but only one of them is considered the `main` one
  """
  colonyMemberInvite: ColonyMemberInvite
    @hasOne(fields: ["colonyMemberInviteCode"])
}

input ValidateUserInviteInput {
  """
  The colony address
  """
  colonyAddress: ID!
  """
  The invite code
  """
  inviteCode: ID!
  """
  The user's wallet address
  """
  userAddress: ID!
}

input InitializeUserInput {
  """
  The user's wallet address
  """
  userAddress: ID!
}

type FailedTransaction {
  """
  Transaction id
  """
  id: ID!
  """
  The current status of the transaction
  """
  status: TransactionStatus!
}

type InitializeUserReturn {
  failedTransactions: [FailedTransaction!]!
}

type ColonyMemberInvite @model {
  """
  Self-managed id which is used as the invite code
  """
  id: ID!
  """
  Colony ID associated with the ColonyMemberInvite
  """
  colonyId: ID!
  """
  Colony associated with the ColonyMemberInvite
  """
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  Decrementing count of how many times this invite has been used
  """
  invitesRemaining: Int!
}

"""
Unclaimed staking rewards for a motion
"""
type ColonyUnclaimedStake {
  """
  The on chain id of the motion
  """
  motionId: String!
  """
  List of unclaimed staking rewards for that motion
  """
  unclaimedRewards: [StakerRewards!]!
}

enum ExternalLinks {
  Custom
  Whitepaper
  Youtube
  Discord
  Telegram
  Github
  Twitter
  Facebook
  Instagram
}

type ExternalLink {
  name: ExternalLinks!
  link: String!
}

type ColonyObjective {
  """
  Title of the objective
  """
  title: String!
  """
  Description of the objective with a limit of 120 characters
  """
  description: String!
  """
  Number representing how complete the objective is, must be between 0 and 100
  """
  progress: Int!
}

type ColonyMetadataEtherealData {
  colonyName: String!
  colonyDisplayName: String!
  colonyAvatar: String
  colonyThumbnail: String
  tokenAvatar: String
  tokenThumbnail: String
  initiatorAddress: ID!
}

"""
Represents metadata for a Colony
"""
type ColonyMetadata @model {
  """
  Unique identifier for the Colony (contract address)
  """
  id: ID!
  """
  Display name of the Colony
  """
  displayName: String!
  """
  Description of the colony
  """
  description: String
  """
  An array of external links to related pages
  """
  externalLinks: [ExternalLink!]
  """
  URL of the Colony's avatar image
  """
  avatar: String
  """
  URL of the Colony's thumbnail image
  """
  thumbnail: String
  """
  List of Colony metadata changelog entries
  """
  changelog: [ColonyMetadataChangelog!]
  """
  Colony Objective
  """
  objective: ColonyObjective
  """
  List of safes that are used within the Colony
  """
  safes: [Safe!]
  """
  Temporary data to store while the colony is being created (via the block ingestor)
  """
  etherealData: ColonyMetadataEtherealData
}

"""
Represents a changelog entry for Colony metadata
This is used to traverse through the history of metadata values and consolidate them into a final state
"""
type ColonyMetadataChangelog {
  """
  Transaction hash associated with the changelog entry
  """
  transactionHash: String!
  """
  Display name of the Colony before the change
  """
  oldDisplayName: String!
  """
  Display name of the Colony after the change
  """
  newDisplayName: String!
  """
  Indicates whether the avatar has changed
  """
  hasAvatarChanged: Boolean!
  """
  Whether the colony description has changed
  """
  hasDescriptionChanged: Boolean
  """
  Whether the colony's external links have changed
  """
  haveExternalLinksChanged: Boolean
  """
  Whether the colony's objective has changed
  """
  hasObjectiveChanged: Boolean
  """
  Whether safes have been added or removed from the Colony's safe list
  """
  newSafes: [Safe!]
  oldSafes: [Safe!]
}

enum ClientType {
  # Styling like this on purpose to maintain ease of compatibility with typescript equivalent
  CoinMachineClient
  ColonyClient
  EvaluatedExpenditureClient
  FundingQueueClient
  MotionTargetClient
  NetworkClient
  OneTxPaymentClient
  ReputationBootstrapperClient
  StakedExpenditureClient
  StagedExpenditureClient
  StreamingPaymentsClient
  TokenSupplierClient
  TokenClient
  TokenLockingClient
  VotingReputationClient
  WhitelistClient
  LightTokenClient
  MultisigPermissionsClient
}

enum TransactionStatus {
  CREATED
  READY
  PENDING
  FAILED
  SUCCEEDED
}

type TransactionGroup {
  id: String!
  groupId: String!
  index: Int!
  key: String!
  title: String # JSON string
  titleValues: String # JSON string
  description: String # JSON string
  descriptionValues: String # JSON string
}

enum TransactionErrors {
  ESTIMATE
  EVENT_DATA
  RECEIPT
  SEND
  UNSUCCESSFUL
}

type TransactionError {
  type: TransactionErrors!
  message: String!
}

"""
Represents a transaction made in a colony by a user
"""
type Transaction @model {
  """
  Transaction id
  """
  id: ID!
  """
  The contract the transaction was made on
  """
  context: ClientType!
  """
  Time the transaction was created
  """
  createdAt: AWSDateTime!
  """
  The sender of the transaction
  """
  from: ID!
    @index(
      name: "byInitiatorAddress"
      queryField: "getTransactionsByUser"
      sortKeyFields: ["createdAt"]
    )
  """
  The colony the transaction was made in
  """
  colonyAddress: ID!
  """
  The id of the group to which the transaction belongs
  """
  groupId: ID!
    @index(
      name: "byGroup"
      queryField: "getTransactionsByUserAndGroup"
      sortKeyFields: ["from"]
    )
  """
  The group to which the transaction belongs
  """
  group: TransactionGroup!
  """
  The transaction hash
  """
  hash: String
  """
  The block number of the transaction
  """
  blockNumber: Int
  """
  The block hash of the transaction
  """
  blockHash: String
  """
  The error associated with the transaction, if any
  """
  error: TransactionError
  """
  The params the transaction was called with
  """
  params: String # a JSON stringified array
  """
  Context in which method is used e.g. setOneTxRole
  """
  methodContext: String
  """
  The name of the contract method used
  """
  methodName: String!
  """
  The current status of the transaction
  """
  status: TransactionStatus!
  """
  A title to show in the UI
  """
  title: String # JSON string
  """
  Title values for FormatJS interpolation
  """
  titleValues: String # JSON string
  """
  The transaction's gas limit
  """
  gasLimit: String
  """
  The transaction's gas price
  """
  gasPrice: String
  """
  An identifier for the transaction
  """
  identifier: String
  """
  Event data associated with a successful transaction
  """
  eventData: String # JSON string
  """
  A contract address associated with a successful transaction
  """
  deployedContractAddress: String
  """
  True if a related transaction is loading
  """
  loadingRelated: Boolean
  """
  Transaction receipt
  """
  receipt: String # JSON string
  """
  Is the transaction cancelled?
  """
  deleted: Boolean
  """
  Options associated with the transaction
  """
  options: String # JSON string
}

"""
Represents a User within the Colony Network
"""
type User @model {
  """
  Unique identifier for the user (wallet address)
  """
  id: ID! @index(name: "byAddress", queryField: "getUserByAddress")
  """
  List of tokens the user is using
  """
  tokens: [Token] @manyToMany(relationName: "UserTokens")
  """
  Profile ID associated with the user
  """
  profileId: ID
  """
  Profile information of the user
  """
  profile: Profile @hasOne(fields: ["profileId"])
  """
  List of domains with the user's permissions in each domain
  """
  roles: [ColonyRole] @hasMany(indexName: "byTargetAddress", fields: ["id"])
  """
  A user's transaction history, broken down by colony
  """
  transactionHistory: [Transaction!]
    @hasMany(indexName: "byInitiatorAddress", fields: ["id"])

  """
  A user who has been invited by colony will be able to pass on the private beta invite
  """
  privateBetaInviteCode: PrivateBetaInviteCode @hasOne
  """
  Bridge customer id
  """
  bridgeCustomerId: String
    @index(name: "byBridgeCustomerId", queryField: "getUserByBridgeCustomerId")
  """
  Bridge liquidation address associated with the user
  """
  liquidationAddresses: [LiquidationAddress!]
    @hasMany(indexName: "byUserAddress", fields: ["id"])
  """
  Notifications data for the user
  """
  notificationsData: NotificationsData @hasOne(fields: "id")
}

"""
Holds the notifications data for the user, such as their unique Magicbell user id, and their notifications preferences.
"""
type NotificationsData @model {
  """
  Unique identifier for the user
  """
  userAddress: ID! @primaryKey
  """
  Unique identifier for the user in Magicbell
  """
  magicbellUserId: ID!
  """
  Boolean to indicate if the user has disabled notifications app wide
  """
  notificationsDisabled: Boolean!
  """
  List of addresses of colonies that the user has muted
  """
  mutedColonyAddresses: [ID!]!
  """
  Boolean to indicate if the user has disabled payment notifications
  """
  paymentNotificationsDisabled: Boolean!
  """
  Boolean to indicate if the user has disabled mention notifications
  """
  mentionNotificationsDisabled: Boolean!
  """
  Boolean to indicate if the user has disabled admin notifications
  """
  adminNotificationsDisabled: Boolean!
}

"""
NOTE: This model should only be used to lookup users by liquidation address
To get the liquidation address of a user, use the `bridgeGetUserLiquidationAddress` query instead
"""
type LiquidationAddress @model {
  """
  Unique identifier for the liquidation address entry
  """
  id: ID!
  """
  The chain id the colony is on
  """
  chainId: Int!
  """
  The user address associated
  """
  userAddress: ID!
    @index(
      name: "byUserAddress"
      queryField: "getLiquidationAddressesByUserAddress"
    )
  """
  The user associated
  """
  user: User @hasOne(fields: ["userAddress"])
  """
  The liquidation address
  """
  liquidationAddress: ID!
    @index(
      name: "byLiquidationAddress"
      queryField: "getUserByLiquidationAddress"
    )
}

"""
Represents a Domain within the Colony Network
"""
type Domain @model {
  """
  Unique identifier for the Domain
  This should be in the following format: `colonyAddress_nativeId`
  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  # Has to be self-managed
  id: ID!
  """
  Colony ID associated with the Domain
  """
  colonyId: ID!
    @index(
      name: "byColony"
      sortKeyFields: ["nativeId"]
      queryField: "getDomainsByColony"
    )
  """
  Colony associated with the Domain
  """
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  Native ID of the Domain
  The native id is the auto-incrementing integer that is assigned to a domain from the contract on creation
  """
  nativeId: Int!
  """
  Native funding pot ID of the Domain
  The native funding pot ID is assigned to a domain from the contract on creation
  """
  nativeFundingPotId: Int!
  """
  Native skill ID of the Domain
  The native skill ID is assigned to a domain from the contract on creation
  """
  nativeSkillId: String!
    @index(
      name: "byNativeSkillId"
      queryField: "getDomainByNativeSkillId"
      sortKeyFields: ["nativeId"]
    )
  """
  Indicates whether the Domain is the root domain (ID 1)
  """
  isRoot: Boolean!
  """
  Metadata of the Domain
  """
  metadata: DomainMetadata @hasOne(fields: ["id"])

  """
  The amount of reputation in the domain
  """
  reputation: String

  """
  The amount of reputation in the domain, as a percentage of the total in the colony
  """
  reputationPercentage: String
}

"""
Represents metadata for a Domain
"""
type DomainMetadata @model {
  """
  Unique identifier for the Domain metadata
  This field is referenced by Domain id, so has to be in the same format: colonyAddress_nativeId
  """
  id: ID!
  """
  Name of the Domain
  """
  name: String!
  """
  Description of the Domain
  """
  description: String
  """
  Color associated with the Domain
  """
  color: DomainColor!
  """
  List of Domain metadata changelog entries
  """
  changelog: [DomainMetadataChangelog!]
}

"""
Represents a changelog entry for Domain metadata
"""
type DomainMetadataChangelog {
  """
  Transaction hash associated with the changelog entry
  """
  transactionHash: String!
  """
  Name of the Domain before the change
  """
  oldName: String!
  """
  Name of the Domain after the change
  """
  newName: String!
  """
  Color of the Domain before the change
  """
  oldColor: DomainColor!
  """
  Color of the Domain after the change
  """
  newColor: DomainColor!
  """
  Description of the Domain before the change
  """
  oldDescription: String
  """
  Description of the Domain after the change
  """
  newDescription: String
}

"""
Represents a Colony Funds Claim for all ERC20 tokens (except native chain tokens)
"""
type ColonyFundsClaim @model {
  """
  Unique identifier for the Colony Funds Claim
  """
  id: ID! @index(sortKeyFields: ["createdAt"])
  """
  The identifier of the Colony the Colony Funds Claim belong to
  """
  colonyFundsClaimsId: ID
    @index(
      name: "byColony"
      sortKeyFields: ["createdAt"]
      queryField: "getFundsClaimsByColony"
    )
  """
  Token associated with the Colony Funds Claim
  """
  token: Token! @hasOne
  """
  Block number when the Funds Claim was created
  """
  createdAtBlock: Int!
  """
  Timestamp when the Funds Claim was created
  """
  createdAt: AWSDateTime!
  """
  Amount claimed in the Colony Funds Claim
  """
  amount: String!
  """
  Boolean to indicate whether the claim has been claimed or not
  """
  isClaimed: Boolean
}

# This is really not elegant, but there's no other proper solution, as you can't # return the Token @hadOne relationship from the lambda function # Note that we don't need token details for the values that we're fetching (since # it's implied), but it would have been nice not to have to basically repeat the type
"""
Represents a native Colony Chain Funds Claim
E.g., Token 0x0000...0000: ETH, xDAI, etc
"""
type ColonyChainFundsClaim {
  """
  Unique identifier for the Colony Chain Funds Claim
  """
  id: ID!
  """
  Block number when the Chain Funds Claim was created
  """
  createdAtBlock: Int!
  """
  Timestamp when the Chain Funds Claim was created
  """
  createdAt: AWSDateTime!
  """
  Timestamp when the Chain Funds Claim was last updated
  """
  updatedAt: AWSDateTime!
  """
  Amount claimed in the Colony Chain Funds Claim
  """
  amount: String!
  """
  Boolean to indicate whether the claim has been claimed or not
  """
  isClaimed: Boolean
}

# This is not a @model since it will only be returned by a lambda function # so don't need to create tables for them
# Note that we also need input types since it treats the `balances` as available
# to "write" to at creation time, even though, even if you were to write to
# you'd never actually be able to read that data since the return is overwritten # by the lambda function
"""
Represents a Colony balance for a specific domain and token
"""
type ColonyBalance {
  """
  Unique identifier for the Colony Balance
  """
  id: ID!
  """
  Balance of the specific token in the domain
  """
  balance: String!
  """
  Domain associated with the Colony Balance
  """
  domain: Domain
  """
  Token associated with the Colony Balance
  Note that for the chain native token, name and symbol are empty
  """
  token: Token!
}

"""
Represents a collection of Colony balances
"""
type ColonyBalances {
  """
  List of Colony balances
  """
  items: [ColonyBalance]
}

"""
Input type for specifying a Domain
"""
input DomainInput {
  """
  Unique identifier for the Domain
  """
  id: ID!
}

"""
Input type for specifying a Token
"""
input TokenInput {
  """
  Unique identifier for the Token
  """
  id: ID!
}

"""
Input type for modifying the staked side of a motion
"""
input MotionStakeValuesInput {
  """
  Number of votes for this motion
  """
  yay: String!
  """
  Number of votes against this motion
  """
  nay: String!
}

"""
Staked sides of a motion
"""
type MotionStakeValues {
  """
  Number of votes for this motion
  """
  yay: String!
  """
  Number of votes against this motion
  """
  nay: String!
}

"""
Input used to modify the staked sides of a motion
"""
input MotionStakesInput {
  """
  Absolute values denominated in the native token
  """
  raw: MotionStakeValuesInput!
  """
  Values in percentage of the total stakes
  """
  percentage: MotionStakeValuesInput!
}

"""
Staked sides of a motion
"""
type MotionStakes {
  """
  Absolute values denominated in the native token
  """
  raw: MotionStakeValues!
  """
  Values in percentage of the total stakes
  """
  percentage: MotionStakeValues!
}

"""
Input used to modify the stakes of a user for a motion
"""
input UserMotionStakesInput {
  """
  The user's wallet address
  """
  address: String!
  """
  Stake values
  """
  stakes: MotionStakesInput!
}

"""
Stakes that a user has made for a motion
"""
type UserMotionStakes {
  """
  The user's wallet address
  """
  address: String!
  """
  Stake values
  """
  stakes: MotionStakes!
}

"""
Input used to modify the staker rewards of a user for a motion
"""
input StakerRewardsInput {
  """
  The user's wallet address
  """
  address: String!
  """
  Rewards associated with the staked sides of a motion
  """
  rewards: MotionStakeValuesInput!
  """
  Whether the voter reward is already claimed or not
  """
  isClaimed: Boolean!
}

"""
Staker rewards of a user for a motion
"""
type StakerRewards {
  """
  The user's wallet address
  """
  address: String!
  """
  Rewards associated with the staked sides of a motion
  """
  rewards: MotionStakeValues!
  """
  Whether the voter reward is already claimed or not
  """
  isClaimed: Boolean!
}

"""
Other motion voting rewards
"""
type VoterRewardsHistory @model {
  id: ID!
  userAddress: ID!
    @index(
      name: "byUser"
      queryField: "getUserVoterRewards"
      sortKeyFields: ["createdAt"]
    )
  user: User! @hasOne(fields: ["userAddress"])
  colonyAddress: ID!
  amount: String!
  motionId: ID!
    @index(
      name: "byMotionId"
      queryField: "getMotionVoterRewards"
      sortKeyFields: ["createdAt"]
    )
  createdAt: AWSDateTime!
}

"""
Input used to modify a voter record of a user for a motion
"""
input VoterRecordInput {
  """
  The user's wallet address
  """
  address: String!
  """
  The voting weight denominated by the user's reputation
  """
  voteCount: String!
  """
  The actual vote (yay or nay)
  nullable since we don't know the vote until it's revealed
  """
  vote: Int
}

"""
A voter record of a user for a motion
"""
type VoterRecord {
  """
  The user's wallet address
  """
  address: String!
  """
  The voting weight denominated by the user's reputation
  """
  voteCount: String!
  """
  The actual vote (yay or nay)
  nullable since we don't know the vote until it's revealed
  """
  vote: Int
}

"""
Input used to create a motion status update message
"""
input MotionMessageInput {
  """
  Wallet address of the initiator of the status update
  The zero address is used for messages that don't have an initiator (system messages)
  """
  initiatorAddress: String!
  """
  Internal name of the status update event (e.g. `MotionCreated`, `MotionStaked`, etc.)
  """
  name: String!
  """
  Unique id for the message
  """
  messageKey: String!
  """
  Cast vote attached to the status update (if applicable)
  """
  vote: String
  """
  Token amount relevant to the status update (if applicable)
  """
  amount: String
}

"""
A status update message for a motion (will appear in the motion's timeline)
"""
type MotionMessage @model {
  """
  Wallet address of the initiator of the status update
  The zero address is used for messages that don't have an initiator (system messages)
  """
  initiatorAddress: ID!
  """
  Internal name of the status update event (e.g. `MotionCreated`, `MotionStaked`, etc.)
  """
  name: String!
  """
  Unique id for the message
  """
  messageKey: String!
  """
  The internal database id of the motion
  """
  motionId: ID!
    @index(
      name: "byMotionId"
      queryField: "getMotionMessageByMotionId"
      sortKeyFields: ["createdAt"]
    )
  """
  Extended user object for given initiatorAddress
  """
  initiatorUser: User @hasOne(fields: ["initiatorAddress"])
  """
  Cast vote attached to the status update (if applicable)
  """
  vote: String
  """
  Token amount relevant to the status update (if applicable)
  """
  amount: String
  """
  Timestamp of when the status update was created in the database
  """
  createdAt: AWSDateTime!
}

"""
Input used to change the current state of a motion
"""
input MotionStateHistoryInput {
  """
  Voting period is elapsed
  """
  hasVoted: Boolean!
  """
  Whether the motion has passed
  """
  hasPassed: Boolean!
  """
  Whether the motion has failed
  """
  hasFailed: Boolean!
  """
  Whether the motion has failed and cannot be finalized (e.g. if it doesn't get staked)
  """
  hasFailedNotFinalizable: Boolean!
  """
  Motion is in reveal phase (votes are being revealed)
  """
  inRevealPhase: Boolean!
  """
  The timestamp when the YAY side was fully staked
  """
  yaySideFullyStakedAt: AWSDateTime
  """
  The timestamp when the NAY side was fully staked
  """
  naySideFullyStakedAt: AWSDateTime
  """
  The timestamp when all votes were submitted
  """
  allVotesSubmittedAt: AWSDateTime
  """
  The timestamp when all votes were revealed
  """
  allVotesRevealedAt: AWSDateTime
  """
  The timestamp when the motion ended (Passed or failed)
  """
  endedAt: AWSDateTime
  """
  The timestamp when the motion was finalized
  """
  finalizedAt: AWSDateTime
}

"""
Quick access flages to check the current state of a motion in its lifecycle
"""
type MotionStateHistory {
  """
  Voting period is elapsed
  """
  hasVoted: Boolean!
  """
  Whether the motion has passed
  """
  hasPassed: Boolean!
  """
  Whether the motion has failed
  """
  hasFailed: Boolean!
  """
  Whether the motion has failed and cannot be finalized (e.g. if it doesn't get staked)
  """
  hasFailedNotFinalizable: Boolean!
  """
  Motion is in reveal phase (votes are being revealed)
  """
  inRevealPhase: Boolean!
  """
  The timestamp when the YAY side was fully staked
  """
  yaySideFullyStakedAt: AWSDateTime
  """
  The timestamp when the NAY side was fully staked
  """
  naySideFullyStakedAt: AWSDateTime
  """
  The timestamp when all votes were submitted
  """
  allVotesSubmittedAt: AWSDateTime
  """
  The timestamp when all votes were revealed
  """
  allVotesRevealedAt: AWSDateTime
  """
  The timestamp when the motion ended (Passed or failed)
  """
  endedAt: AWSDateTime
  """
  The timestamp when the motion was finalized
  """
  finalizedAt: AWSDateTime
}

enum MultiSigVote {
  None
  Approve
  Reject
}

type MultiSigUserSignature @model {
  id: ID!
  colonyAddress: ID!
  multiSigId: ID!
    @index(
      name: "byMultiSigId"
      queryField: "getMultiSigUserSignatureByMultiSigId"
    )
  role: Int!
  userAddress: ID!
  user: User! @hasOne(fields: ["userAddress"])
  vote: MultiSigVote!
  createdAt: AWSDateTime!
}

"""
Represents a MultiSig motion within a Colony
"""
type ColonyMultiSig @model {
  """
  The internal database id of the multiSig
  To ensure uniqueness, we format as: `chainId-multiSigExtnAddress_nativeMultiSigId`
  """
  id: ID!
  """
  Colony address the multiSig belongs to
  """
  colonyAddress: ID!
    @index(name: "byColonyAddress", queryField: "getMultiSigByColonyAddress")
  """
  The on chain id of the multiSig
  """
  nativeMultiSigId: ID!
  """
  Unique identifier of the multiSigs domain in the database
  """
  multiSigDomainId: ID!
  """
  Expanded domain in which the multiSig was created
  """
  multiSigDomain: Domain! @hasOne(fields: ["multiSigDomainId"])
  """
  The on chain id of the domain associated with the motion
  """
  nativeMultiSigDomainId: String! # native domain id
  """
  Signatures info
  """
  signatures: [MultiSigUserSignature]
    @hasMany(indexName: "byMultiSigId", fields: ["id"])
  """
  Required role for signing
  """
  requiredPermissions: Int!
  """
  Whether the multiSig was executed or not
  """
  isExecuted: Boolean!
  """
  Whether the underlying action completed
  """
  hasActionCompleted: Boolean!
  """
  Whether the multiSig was cancelled or not
  """
  isRejected: Boolean!
  """
  Whether the multiSig is a Simple Decision
  """
  isDecision: Boolean!
  """
  The transaction hash of the creteMotion (multisig) action
  """
  transactionHash: ID!
    @index(
      name: "byTransactionHash"
      queryField: "getMultiSigByTransactionHash"
    )

  action: ColonyAction @belongsTo(fields: ["transactionHash"])
  """
  The timestamp when the motion was finalized
  """
  executedAt: AWSDateTime
  """
  Wallet address of the user finalizing the motion
  """
  executedBy: ID
  """
  Extended user object for given executedBy
  """
  executedByUser: User @hasOne(fields: ["executedBy"])
  """
  Wallet address of the user rejecting the motion
  """
  rejectedBy: ID
  """
  Extended user object for given rejectedBy
  """
  rejectedByUser: User @hasOne(fields: ["rejectedBy"])
  """
  The timestamp when the motion was rejected
  """
  rejectedAt: AWSDateTime
  """
  The timestamp when the motion was created at
  """
  createdAt: AWSDateTime!
}
"""
Represents a Motion within a Colony
"""
type ColonyMotion @model {
  """
  The internal database id of the motion
  To ensure uniqueness, we format as: `chainId-votingRepExtnAddress_nativeMotionId`
  """
  id: ID!
  """
  The on chain id of the motion
  """
  nativeMotionId: String!
  """
  List of stakes that users have made for a motion
  """
  usersStakes: [UserMotionStakes!]!
  """
  List of staker rewards users will be receiving for a motion
  """
  stakerRewards: [StakerRewards!]!
  """
  List of other rewards users will be receiving for a motion, such as voting
  """
  voterRewards: [VoterRewardsHistory!]
    @hasMany(indexName: "byMotionId", fields: ["id"])
  """
  Staked sides of a motion
  """
  motionStakes: MotionStakes!
  """
  Stakes remaining to activate either side of the motion
  It's a tuple: `[nayRemaining, yayRemaining]`
  """
  remainingStakes: [String!]!
  """
  The minimum stake that a user has to provide for it to be accepted
  """
  userMinStake: String!
  """
  The total required stake for one side to be activated
  """
  requiredStake: String!
  """
  Unique identifier of the motions domain in the database
  """
  motionDomainId: ID!
  """
  Expanded domain in which the motion was created
  """
  motionDomain: Domain! @hasOne(fields: ["motionDomainId"])
  """
  The on chain id of the domain associated with the motion
  """
  nativeMotionDomainId: String! # native domain id
  """
  Whether the motion was finalized or not
  """
  isFinalized: Boolean!
  """
  Address of the VotingReputation extension
  Useful to check if we're viewing a "read-only" motion
  """
  createdBy: String!
  """
  A list of all of the votes cast within in the motion
  """
  voterRecord: [VoterRecord!]!
  """
  Total voting outcome for the motion (accumulated votes)
  """
  revealedVotes: MotionStakes! ## I.e. MotionVotes (same type)
  """
  The amount of reputaion that has submitted a vote
  """
  repSubmitted: String!
  """
  The total amount of reputation (among all users) that can vote for this motion
  """
  skillRep: String!
  """
  Simple flag indicating whether both sides of staking have been activated
  """
  hasObjection: Boolean!
  """
  Quick access flages to check the current state of a motion in its lifecycle
  """
  motionStateHistory: MotionStateHistory!
  """
  List of motion status update messages
  """
  messages: [MotionMessage!]! @hasMany(indexName: "byMotionId", fields: ["id"])

  """
  Id of the associated objection annotation, if any
  """
  objectionAnnotationId: ID
  """
  The annotation object associated with the objection to the motion, if any
  """
  objectionAnnotation: Annotation @hasOne(fields: ["objectionAnnotationId"])
  """
  Whether the motion is a Simple Decision
  """
  isDecision: Boolean!
  """
  The transaction hash of the createMotion action
  """
  transactionHash: ID!
    @index(name: "byTransactionHash", queryField: "getMotionByTransactionHash")

  """
  Expenditure associated with the motion, if any
  """
  expenditureId: ID
    @index(name: "byExpenditureId", queryField: "getMotionByExpenditureId")

  """
  Ids of the staged payment slots to be released if the motion pass, if any
  """
  expenditureSlotIds: [Int!]

  action: ColonyAction @belongsTo(fields: ["transactionHash"])

  """
  Edited expenditure slots associated with the motion, if any
  """
  editedExpenditureSlots: [ExpenditureSlot!]

  """
  In case of multicall motion funding an expenditure, array containing
  the details of tokens and amounts to be funded
  """
  expenditureFunding: [ExpenditureFundingItem!]
}

type ExpenditureFundingItem {
  """
  The amount of the token to be funded
  """
  amount: String!
  """
  The token address of the token to be funded
  """
  tokenAddress: String!
}

"""
Represents an event triggered by a smart contract within the Colony Network
""" # This will store the relevant events we care about for a particular colony # Altough it might also hold events emmited by other clients (eg: network or token) # but are event pertaining to a colony # Generally you'd want to use this from a block ingenstor, after you've processed # data from an event, also save that even for future use
type ContractEvent @model {
  """
  Unique identifier for the Contract Event, in the format chainID_transactionHash_logIndex
  """
  id: ID!
  """
  Name of the event
  """
  # i'm debating if this should be a enum or not, but this was you don't have to
  # update this schema every time you want to start tracking a new event
  name: String!
  """
  The unique signature of the event
  """
  signature: String!
  """
  Metadata associated with the event's chain
  """
  chainMetadata: ChainMetadata!
  """
  Optional association with a Colony
  """
  colony: Colony @hasOne
  """
  Optional association with a Token
  """
  token: Token @hasOne
  """
  Optional association with a Domain
  """
  domain: Domain @hasOne
  """
  Optional association with a User
  """
  user: User @hasOne
  """
  Address of the agent who initiated the event
  """
  agent: String!
  """
  Address of the target contract on the receiving end of the event
  """
  target: String!
  """
  Optional encoded arguments as a JSON string
  """
  encodedArguments: String
}

"""
Parameters that were set when installing the VotingReputation extension
For more info see [here](https://docs.colony.io/colonysdk/api/classes/VotingReputation#extension-parameters)
"""
type VotingReputationParams {
  """
  Percentage of the team's reputation that needs to be staked ot activate either side of the motion
  """
  totalStakeFraction: String!
  """
  Percentage of the losing side's stake that is awarded to the voters
  """
  voterRewardFraction: String!
  """
  Minimum percentage of the total stake that each user has to provide
  """
  userMinStakeFraction: String!
  """
  Percentage of the total reputation that voted should end the voting period
  """
  maxVoteFraction: String!
  """
  Time that the staking period will last (in seconds)
  """
  stakePeriod: String!
  """
  Time that the voting period will last (in seconds)
  """
  submitPeriod: String!
  """
  Time that the reveal period will last (in seconds)
  """
  revealPeriod: String!
  """
  Time that the escalation period will last (in seconds)
  """
  escalationPeriod: String!
}

type MultiSigDomainConfig {
  domainId: ID!
  domainThreshold: Int!
}

type MultiSigParams {
  colonyThreshold: Int!
  domainThresholds: [MultiSigDomainConfig]
}

type StakedExpenditureParams {
  stakeFraction: String!
}

"""
Map of parameters that extensions are initialised with
"""
type ExtensionParams {
  """
  Initialization parameters for the `VotingReputation` extension
  """
  votingReputation: VotingReputationParams
  """
  Initialization parameters for the `StakedExpenditure` extension
  """
  stakedExpenditure: StakedExpenditureParams
  """
  Params for MultiSig
  """
  multiSig: MultiSigParams
}

"""
Represents a single extension installation in a Colony
"""
type ColonyExtension @model {
  """
  Unique identifier for the ColonyExtension
  """
  id: ID!
  """
  The identifier of the Colony that the extension belongs to (the Colony's address)
  """
  colonyId: ID!
    @index(
      name: "byColony"
      sortKeyFields: ["hash"]
      queryField: "getExtensionByColonyAndHash"
    )
  """
  The Colony that the extension belongs to
  """
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  The unique hash of the extension
  The hash is generated like so: `keccak256(toUtf8Bytes(extensionName))`, where `extensionName` is the name of the extension contract file in the Colony Network
  """
  hash: String! @index(name: "byHash", queryField: "getExtensionsByHash")
  """
  The address of the user who installed the extension
  """
  installedBy: String!
  """
  The timestamp when the extension was installed
  """
  installedAt: AWSTimestamp!
  """
  Indicates whether the extension is deprecated
  """
  isDeprecated: Boolean!
  """
  Indicates whether the extension has been removed
  """
  isDeleted: Boolean!
  """
  Indicates whether the extension has been initialized
  """
  isInitialized: Boolean!
  """
  The version number of the extension
  """
  version: Int!
  """
  Map of parameters that extension was initialised with
  """
  params: ExtensionParams
}

"""
Represents the current version of an entity in the system
"""
type CurrentVersion @model {
  """
  Unique identifier for the CurrentVersion
  """
  id: ID!
  """
  The key used to look up the current version
  """
  key: String! @index(name: "byKey", queryField: "getCurrentVersionByKey")
  """
  The current version number
  """
  version: Int!
}

"""
The current inverse of the network fee (in wei)
(divide 1 by it and get the actual network fee)
"""
type CurrentNetworkInverseFee @model {
  """
  Unique identifier for the network fee
  """
  id: ID!
  """
  The inverse fee
  """
  inverseFee: String!
}

type Payment {
  """
  Payment amount, excluding network fee
  """
  amount: String!
  """
  Network fee amount
  """
  networkFee: String
  tokenAddress: String!
  recipientAddress: String!
}
"""
Represents an action performed within a Colony
"""
type ColonyAction @model @searchable {
  """
  Unique identifier for the ColonyAction
  """
  id: ID!
  """
  The identifier of the Colony that the action belongs to
  """
  colonyId: ID!
    @index(
      name: "byColony"
      queryField: "getActionsByColony"
      sortKeyFields: ["createdAt"]
    )
  """
  The Colony that the action belongs to
  """
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  The type of action performed
  """
  type: ColonyActionType!
  """
  The block number where the action was recorded
  """
  blockNumber: Int!
  """
  Will be true if the action is a motion
  """
  isMotion: Boolean
  """
  The internal database id of the motion
  """
  motionId: ID
    @index(name: "byMotionId", queryField: "getColonyActionByMotionId")
  """
  Expanded `ColonyMotion` for the corresponding `motionId`
  """
  motionData: ColonyMotion @hasOne(fields: ["motionId"])
  """
  Will be true if the action is a multiSig motion
  """
  isMultiSig: Boolean
  """
  The internal database id of the multiSig
  """
  multiSigId: ID
    @index(name: "byMultiSigId", queryField: "getColonyActionByMultiSigId")
  """
  Expanded `ColonyMultiSig` for the corresponding `multiSigId`
  """
  multiSigData: ColonyMultiSig @hasOne(fields: ["multiSigId"])
  """
  Whether to show the motion in the actions list
  True for (forced) actions. True for motions if staked above 10%
  @TODO: Refactor this into more granular fields for better searchability
  Currently it is impossible to tell the reason for the action being hidden from the actions list
  """
  showInActionsList: Boolean!
  """
  The timestamp when the action was created
  """
  createdAt: AWSDateTime!
  """
  The Ethereum address of the action initiator. Can be a user, extension or colony
  """
  initiatorAddress: ID!

  # Action type specific fields which might be null

  # Amplify will automatically populate one of the following fields with related model if there is an initiator
  """
  The User who initiated the action, if applicable
  """
  initiatorUser: User @hasOne(fields: ["initiatorAddress"])
  """
  The ColonyExtension that initiated the action, if applicable
  """
  initiatorExtension: ColonyExtension @hasOne(fields: ["initiatorAddress"])
  """
  The Colony that initiated the action, if applicable
  """
  initiatorColony: Colony @hasOne(fields: ["initiatorAddress"])
  """
  The Token contract that initiated the action, if applicable
  """
  initiatorToken: Token @hasOne(fields: ["initiatorAddress"])

  # Amplify will automatically populate one of the following fields with related model if there is an recipient
  """
  The address of the action recipient, if applicable
  """
  recipientAddress: ID
  """
  The User who received the action, if applicable
  """
  recipientUser: User @hasOne(fields: ["recipientAddress"])
  """
  The corresponding Colony which was involved the action, if applicable
  """
  recipientColony: Colony @hasOne(fields: ["recipientAddress"])
  """
  The corresponding extension which was involved the action, if applicable
  """
  recipientExtension: ColonyExtension @hasOne(fields: ["recipientAddress"])
  """
  The address of the token that was received the action, if applicable
  """
  recipientToken: Token @hasOne(fields: ["recipientAddress"])
  """
  The amount involved in the action, if applicable
  In any case where network fee is involved, this amount excludes it
  """
  amount: String
  """
  The network fee amount, if applicable
  """
  networkFee: String
  """
  The Ethereum address of the token involved in the action, if applicable
  """
  tokenAddress: ID
  """
  The Token involved in the action, if applicable
  """
  token: Token @hasOne(fields: ["tokenAddress"])
  """
  The source Domain identifier, if applicable
  """
  fromDomainId: ID
  """
  The source Domain of the action, if applicable
  """
  fromDomain: Domain @hasOne(fields: ["fromDomainId"])
  """
  The target Domain identifier, if applicable
  """
  toDomainId: ID
  """
  The target Domain of the action, if applicable
  """
  toDomain: Domain @hasOne(fields: ["toDomainId"])
  """
  The native ID of the source funding pot, only applicable for MOVE_FUNDS action
  """
  fromPotId: Int
  """
  The native ID of the target funding pot, only applicable for MOVE_FUNDS action
  """
  toPotId: Int
  """
  The native id of the payment
  """
  paymentId: Int
  """
  The resulting new Colony version, if applicable
  """
  newColonyVersion: Int
  """
  Identifier of domain metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingDomainMetadataId: ID
  """
  Domain metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingDomainMetadata: DomainMetadata
    @hasOne(fields: ["pendingDomainMetadataId"])
  """
  Identifier of Colony metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingColonyMetadataId: ID
  """
  Colony metadata that is stored temporarily and commited to the database once the corresponding motion passes
  """
  pendingColonyMetadata: ColonyMetadata
    @hasOne(fields: ["pendingColonyMetadataId"])
  """
  The id of the associated annotation, if there is one
  """
  annotationId: ID
  """
  The annotation associated with the action, if there is one
  """
  annotation: Annotation @hasOne(fields: ["annotationId"])
  """
  Corresponding domainId of the motion
  """
  motionDomainId: Int
  """
  If the action is a Simple Decision, it will have an id that corresponds to a ColonyDecision entry in the database.
  """
  colonyDecisionId: ID
  """
  Corresponding Decision data, if action is a Simple Decision
  """
  decisionData: ColonyDecision @hasOne(fields: ["colonyDecisionId"])
  """
  Payment data for multiple OneTxPayments
  """
  payments: [Payment!]
  """
  Colony roles that are associated with the action
  """
  roles: ColonyActionRoles
  """
  Colony roles that are associated with the action are multi sig roles
  """
  rolesAreMultiSig: Boolean
  """
  Members impacted by the action (used for add/remove verified members)
  """
  members: [ID!]
  # Required since some actions might have multiple event entries in the list
  # which need to be iterated over and exposed individually
  #
  # This should be a list/array, but this is yet another thing Amplify is bad at
  # The official response from them is to use DynamoDB directly:
  # https://stackoverflow.com/questions/50992106/append-item-to-list-using-aws-appsync-to-dynamodb
  # Which is just freaking great!
  #
  # As such, I've decided to simplify this, an just pass a stringified JSON around
  # since this is for display purpouses only.
  #
  # If anyone has a better idea on how to handle this, I'll gladly change it!
  #
  # When / if you decide to use it, just be mindful of what format other people
  # are using, and follow suit.
  #
  # Roles Types:
  # [{ id: String, type: String, role: Number, setTo: boolean }]
  """
  JSON string to pass custom, dynamic event data
  """
  individualEvents: String
  """
  Safe transactions associated with the action
  """
  safeTransaction: SafeTransaction @hasOne(fields: ["id"])
  """
  Metadata associated with the action (Eg. Custom action title)
  """
  metadata: ColonyActionMetadata @hasOne(fields: ["id"])
  """
  The reputation root hash at the time of the creation of the action
  """
  rootHash: String!
  """
  ID of the associated expenditure, if any
  """
  expenditureId: ID
    @index(name: "byExpenditureId", queryField: "getActionByExpenditureId")
  """
  Expenditure associated with the action, if any
  """
  expenditure: Expenditure @hasOne(fields: ["expenditureId"])
  """
  Indicates whether the action is a result of a motion being finalized
  @TODO: Make this field non-nullable
  """
  isMotionFinalization: Boolean
  """
  Changes to the expenditure slots associated with the action, if any
  Applicable to `EDIT_EXPENDITURE` action only
  """
  expenditureSlotChanges: ExpenditureSlotChanges
  """
  Approved tokens impacted by the action (used for manage tokens)
  """
  approvedTokenChanges: ApprovedTokenChanges
  """
  Ids of the staged payment slots released by the action, if any
  """
  expenditureSlotIds: [Int!]
}

"""
Token IDs
"""
type ApprovedTokenChanges {
  added: [ID!]!
  removed: [ID!]!
  unaffected: [ID!]!
}

type ExpenditureSlotChanges {
  oldSlots: [ExpenditureSlot!]!
  newSlots: [ExpenditureSlot!]!
}

type ColonyActionMetadata @model {
  id: ID!
  customTitle: String!
}

type ColonyDecision @model {
  id: ID!
  actionId: ID!
    @index(name: "byActionId", queryField: "getColonyDecisionByActionId")
  action: ColonyAction @belongsTo(fields: ["actionId"])
  title: String!
  colonyAddress: String!
    @index(
      name: "byColonyAddress"
      queryField: "getColonyDecisionByColonyAddress"
      sortKeyFields: ["createdAt"]
    )
  createdAt: AWSDateTime!
  description: String!
  motionDomainId: Int!
  walletAddress: String!
  showInDecisionsList: Boolean!
}

"""
Colony Roles that can be involved in an action
""" # Roles have been set as role_<number> so we can more easily map them to their # actual contract counterpart on the client and block ingestor side(s)
type ColonyActionRoles {
  """
  Recovery role
  """
  role_0: Boolean
  """
  Root role
  """
  role_1: Boolean
  """
  Arbitration role
  """
  role_2: Boolean
  """
  Architecture role
  """
  role_3: Boolean
  """
  Funding role
  """
  role_5: Boolean
  """
  Administration role
  """
  role_6: Boolean
}

"""
A snapshot of the current set of permissions a given address has in a given domain within a Colony
"""
type ColonyRole @model {
  """
  Unique identifier for the role snapshot
  Format: `<colonyAddress>_<domainNativeId>_<userAddress>_roles` or `<colonyAddress>_<domainNativeId>_<userAddress>_multisig_roles`
  """
  id: ID! @index
  """
  Unique identifier of the domain
  """
  domainId: ID!
    @index(
      name: "byDomainId"
      queryField: "getRoleByDomainAndColony"
      sortKeyFields: ["colonyAddress"]
    )
  """
  Expanded `Domain` model, based on the `domainId` given
  """
  domain: Domain! @hasOne(fields: ["domainId"])

  # Amplify will automatically populate one of the following fields with related model if it finds one
  """
  Address of the agent the permission was set for
  """
  targetAddress: ID!
    @index(
      name: "byTargetAddress"
      queryField: "getRoleByTargetAddressAndColony"
      sortKeyFields: ["colonyAddress"]
    )

  """
  Will expand to a `User` model if permission was set for a user
  """
  targetUser: User @hasOne(fields: ["targetAddress"])
  """
  Will expand to a `Colony` model if permission was set for another Colony
  """
  targetColony: Colony @hasOne(fields: ["targetAddress"])
  """
  Will expand to a `ColonyExtension` model if permission was set for a Colony extension
  """
  targetExtension: ColonyExtension @hasOne(fields: ["targetAddress"])
  """
  Will expand to a `Token` model if permission was set for a Token contract
  """
  targetToken: Token @hasOne(fields: ["targetAddress"])

  """
  The colony in which the role was set
  """
  colonyAddress: ID!
    @index(
      name: "byColonyAddress"
      queryField: "getRoleByColony"
      sortKeyFields: ["domainId"]
    )
  """
  Block at which permissions were update last
  """
  latestBlock: Int!
  """
  Recovery role
  """
  role_0: Boolean
  """
  Root role
  """
  role_1: Boolean
  """
  Arbitration role
  """
  role_2: Boolean
  """
  Architecture role
  """
  role_3: Boolean
  """
  Funding role
  """
  role_5: Boolean
  """
  Administration role
  """
  role_6: Boolean
  """
  Will be true if the colony role is a multi sig role
  """
  isMultiSig: Boolean
}

"""
Snapshot of the user's full roles/permissions at a specific block
""" # it's a model, not a type since this is designed to work outside of the main # colony model, or colony role model, as, by design it should be only used # in very specific cases
type ColonyHistoricRole @model {
  """
  Unique identifier for the role snapshot
  Format: `<colonyAddress>_<domainNativeId>_<userAddress>_<blockNumber>_roles`  or `<colonyAddress>_<domainNativeId>_<userAddress>_<blockNumber>_multisig_roles`
  """
  id: ID! #
  """
  Used for amplify sorting. Set to `SortedHistoricRole`
  """
  # I HATE AMPLIFY SORTING! MAY IT DIE A THOUSAND DEATHS!
  #
  # @NOTE Always set to `type` to "SortedHistoricRole" to enable Amplify sorting, it DOES NOT WORK with `id`
  #
  # Apparently, it can only filter non-primary fields, meaning that if we sort by `blockNumber` then that
  # field is considered primary, so it won't allow us to filter by it.
  # To overcome this we've sorted by creation date, which is not really correct from a block chain
  # point of view, but due to the nature of the block ingestor, it works for our use case
  type: String!
    @index(
      name: "getColonyHistoricRoleByDate"
      queryField: "getColonyHistoricRoleByDate"
      sortKeyFields: ["createdAt"]
    )

  """
  Unique identifier of the domain
  """
  domainId: ID!
  """
  Expanded `Domain` model, based on the `domainId` given
  """
  domain: Domain! @hasOne(fields: ["domainId"])
  """
  Unique identifier of the Colony
  """
  colonyId: ID!
  """
  Expanded `Colony` model, based on the `colonyId` given
  """
  colony: Colony! @hasOne(fields: ["colonyId"])

  # Amplify will automatically populate one of the following fields with related model if it finds one
  """
  Address of the agent the permission was set for
  """
  targetAddress: ID
  """
  Will expand to a `User` model if permission was set for a user
  """
  targetUser: User @hasOne(fields: ["targetAddress"])
  """
  Will expand to a `Colony` model if permission was set for another Colony
  """
  targetColony: Colony @hasOne(fields: ["targetAddress"])
  """
  Will expand to a `ColonyExtension` model if permission was set for a Colony extension
  """
  targetExtension: ColonyExtension @hasOne(fields: ["targetAddress"])
  """
  Will expand to a `Token` model if permission was set for a Token contract
  """
  targetToken: Token @hasOne(fields: ["targetAddress"])

  """
  Block at which the snapshot was taken
  """
  blockNumber: Int!
  """
  Recovery role
  """
  role_0: Boolean
  """
  Root role
  """
  role_1: Boolean
  """
  Arbitration role
  """
  role_2: Boolean
  """
  Architecture role
  """
  role_3: Boolean
  """
  Funding role
  """
  role_5: Boolean
  """
  Administration role
  """
  role_6: Boolean
  """
  Timestamp at which the database entry was created
  """
  createdAt: AWSDateTime!
  """
  Will be true if the colony role is a multi sig role
  """
  isMultiSig: Boolean
}

"""
Model storing block ingestor stats, as key-value entries
"""
type IngestorStats @model {
  """
  Unique identifier of the ingestor stats
  """
  id: ID!
  """
  JSON string to pass custom, dynamic values
  """
  value: String!
}

type Expenditure @model {
  """
  Unique identifier for the role snapshot
  Self-managed, format: `colonyId_nativeExpenditureId`
  """
  id: ID!
  """
  Native (contract) ID of the expenditure
  """
  nativeId: Int!
  createdAt: AWSDateTime!
  """
  Colony ID (address) to which the expenditure belongs
  """
  colonyId: ID!
    @index(
      name: "byColony"
      queryField: "getExpendituresByColony"
      sortKeyFields: ["createdAt"]
    )
  """
  The Colony to which the expenditure belongs
  """
  colony: Colony! @belongsTo(fields: ["colonyId"])
  """
  Address of the expenditure owner, it can be a user or an extension
  """
  ownerAddress: ID!
  """
  Status of the expenditure
  """
  status: ExpenditureStatus!
  """
  Array containing expenditure slots
  """
  slots: [ExpenditureSlot!]!
  """
  Native (contract) ID of the funding pot of the expenditure
  """
  nativeFundingPotId: Int!
    @index(
      name: "byNativeFundingPotId"
      queryField: "getExpendituresByNativeFundingPotIdAndColony"
      sortKeyFields: ["colonyId"]
    )
  """
  Native (contract) ID of the expenditure domain
  """
  nativeDomainId: Int!
  """
  Array containing balances of tokens in the expenditure
  """
  balances: [ExpenditureBalance!]
  """
  Optional metadata linked to the expenditure
  It contains client-side data that is not stored on chain
  """
  metadata: ExpenditureMetadata @hasOne(fields: ["id"])
  """
  The timestamp at which the expenditure was finalized
  """
  finalizedAt: AWSTimestamp
  """
  The motions created that relate to this expenditure, if there are any
  """
  motions: [ColonyMotion] @hasMany(indexName: "byExpenditureId", fields: ["id"])
  """
  Indicates whether the expenditure was staked for
  """
  isStaked: Boolean!
  type: ExpenditureType!
  """
  Actions associated with the expenditure
  """
  actions: [ColonyAction!]
    @hasMany(indexName: "byExpenditureId", fields: ["id"])
  """
  ID of the user stake associated with the expenditure, if any
  """
  userStakeId: ID
  """
  User stake associated with the expenditure, if any
  """
  userStake: UserStake @hasOne(fields: ["userStakeId"])
  """
  Hash of the first transaction that contained ExpenditurePayoutSet event
  """
  firstEditTransactionHash: String
  """
  Address of StagedExpenditure extension which set the expenditure as staged, if applicable
  """
  stagedExpenditureAddress: ID
  """
  Address of StakedExpenditure extension which created the expenditure, if applicable
  """
  stakedExpenditureAddress: ID
}

"""
Represents a slot of an expenditure
Each expenditure can have multiple slots, with a single recipients and multiple payouts (in different token addresses)
"""
type ExpenditureSlot {
  id: Int!
  recipientAddress: String
  """
  Slot claim delay (in seconds)
  """
  claimDelay: String
  payoutModifier: Int
  payouts: [ExpenditurePayout!]
}

type ExpenditurePayout {
  tokenAddress: ID!
  """
  Payout amount, excluding network fee
  """
  amount: String!
  """
  Network fee amount
  @TODO: Make this a non-nullable field once existing data is updated
  """
  networkFee: String
  isClaimed: Boolean!
}

type ExpenditureMetadata @model {
  id: ID! # Self-managed, formatted as colonyId_nativeId
  fundFromDomainNativeId: Int!
  stages: [ExpenditureStage!]
  expectedNumberOfPayouts: Int
  expectedNumberOfTokens: Int
  """
  Specifies the distribution type selected when creating a split payment
  Will be null for other payment types
  """
  distributionType: SplitPaymentDistributionType
}

type ExpenditureBalance {
  tokenAddress: ID!
  amount: String!
}

type ExpenditureStage {
  slotId: Int!
  name: String!
}

type StreamingPayment @model {
  id: ID! # Self-managed, formatted as colonyId_nativeId
  nativeId: Int!
  createdAt: AWSDateTime!
  recipientAddress: String!
  nativeDomainId: Int!
  startTime: AWSTimestamp!
  endTime: AWSTimestamp!
  interval: String!
  payouts: [ExpenditurePayout!]
  metadata: StreamingPaymentMetadata @hasOne(fields: ["id"])
}

type StreamingPaymentMetadata @model {
  id: ID! # Self-managed, formatted as colonyId_nativeId
  endCondition: StreamingPaymentEndCondition!
  limitAmount: String
}

"""
Defines an annotation for actions, motions and decisions
"""
type Annotation @model {
  """
  The id of the annotation.
  """
  id: ID!
  """
  The id of the action it annotates
  """
  actionId: ID!
  """
  The actual annotation message
  """
  message: String!
  """
  The IPFS hash, if the annotation was also uploaded to IPFS
  """
  ipfsHash: String
}

type ReputationMiningCycleMetadata @model {
  id: ID! # A constant, since we only need one entry in the database: "REPUTATION_MINING_CYCLE_METADATA"
  """
  The timestamp of the most recent reputation mining cycle completion.
  """
  lastCompletedAt: AWSDateTime! # We're using this to determine whether to re-calculate colony-wide user reputation (updateContributorsWithReputation)
}

type PrivateBetaInviteCode @model {
  """
  The id functions as the invite code
  """
  id: ID!
  """
  This tracks the amount of invites this invite code is also allowed to generate
  The default value relates to the initial user and their subsequent invitee
  """
  shareableInvites: Int @default(value: "2")
  """
  User ID associated with the Invite
  """
  userId: ID
}

type SimpleTargetProfile {
  avatarHash: String
  displayName: String
}

type SimpleTarget {
  id: String!
  profile: SimpleTargetProfile!
  walletAddress: String!
}

type NFT {
  id: String!
  profile: NFTProfile!
  walletAddress: String!
}

type NFTProfile {
  displayName: String!
}

type FunctionParam {
  name: String!
  type: String!
  value: String!
}

type NFTData {
  address: String!
  description: String
  id: String!
  imageUri: String
  logoUri: String!
  name: String
  tokenName: String!
  tokenSymbol: String!
  uri: String!
}

enum SafeTransactionType {
  TRANSFER_FUNDS
  TRANSFER_NFT
  CONTRACT_INTERACTION
  RAW_TRANSACTION
}

type SafeTransaction @model {
  id: ID!
  safe: Safe!
  transactions: [SafeTransactionData]
    @hasMany(indexName: "byTransaction", fields: ["id"])
}

type SafeTransactionData @model {
  id: ID!
  tokenAddress: ID
  token: Token @hasOne(fields: ["tokenAddress"])
  amount: String
  rawAmount: String
  recipient: SimpleTarget
  data: String
  contract: SimpleTarget
  abi: String
  contractFunction: String
  nft: NFT
  nftData: NFTData
  functionParams: [FunctionParam]
  transactionType: SafeTransactionType!
  transactionHash: ID! @index(name: "byTransaction", sortKeyFields: ["id"])
}

type Safe {
  name: String!
  address: String!
  chainId: String!
  moduleContractAddress: String!
}

type ExtensionInstallationsCount @model {
  """
  The model id. It's the chain id the of the colony the extension belongs to
  """
  id: ID!
  oneTxPayment: Int!
  stakedExpenditure: Int!
  stagedExpenditure: Int!
  streamingPayments: Int!
  reputationWeighted: Int!
  multiSigPermissions: Int!
}

type UserStake @model {
  """
  Self-managed, formatted as userAddress_transactionHash, where transactionHash is the hash of the transaction that is being staked for
  """
  id: ID!
  userAddress: ID!
    @index(
      name: "byUserAndColony"
      queryField: "getUserStakes"
      sortKeyFields: ["createdAt"]
    )
  user: User! @hasOne(fields: ["userAddress"])
  colonyAddress: ID!
  # TODO: Make this field non-nullable once migration is done
  type: UserStakeType
  amount: String!
  isClaimed: Boolean!
  actionId: ID!
  action: ColonyAction @hasOne(fields: ["actionId"])
  createdAt: AWSDateTime!
  """
  Only applicable for expenditure stakes, indicates if the creator's stake was forfeited when expenditure was cancelled
  """
  isForfeited: Boolean
}
